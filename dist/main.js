!function(n){var i={};function o(t){if(i[t])return i[t].exports;var c=i[t]={i:t,l:!1,exports:{}};return n[t].call(c.exports,c,c.exports,o),c.l=!0,c.exports}o.m=n,o.c=i,o.d=function(n,i,t){o.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,i){if(1&i&&(n=o(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var c in n)o.d(t,c,function(i){return n[i]}.bind(null,c));return t},o.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(i,"a",i),i},o.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},o.p="",o(o.s=2)}([function(module,exports){eval("function Player() {\n    const attack = (board, position) => {\n        board.receiveAttack(position);\n    }\n    return {attack}\n}\n\nmodule.exports = Player;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvUGxheWVyLmpzP2I5NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFBsYXllcigpIHtcbiAgICBjb25zdCBhdHRhY2sgPSAoYm9hcmQsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGJvYXJkLnJlY2VpdmVBdHRhY2socG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge2F0dGFja31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("function Ship(positions) {\n    const positionsHealth = {};\n    positions.forEach(position => positionsHealth[position] = 1);\n\n    const getPositions = () => positionsHealth;\n\n    const hit = (position) => {\n        positionsHealth[position] = 0;\n    }\n    const isSunk = () => {\n        return Object.values(positionsHealth).every(health => health === 0)\n    }\n    return {hit, isSunk, getPositions};\n}\n\nmodule.exports = Ship;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvU2hpcC5qcz9mM2Y5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNoaXAocG9zaXRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb25zSGVhbHRoID0ge307XG4gICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zaXRpb25zSGVhbHRoW3Bvc2l0aW9uXSA9IDEpO1xuXG4gICAgY29uc3QgZ2V0UG9zaXRpb25zID0gKCkgPT4gcG9zaXRpb25zSGVhbHRoO1xuXG4gICAgY29uc3QgaGl0ID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHBvc2l0aW9uc0hlYWx0aFtwb3NpdGlvbl0gPSAwO1xuICAgIH1cbiAgICBjb25zdCBpc1N1bmsgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBvc2l0aW9uc0hlYWx0aCkuZXZlcnkoaGVhbHRoID0+IGhlYWx0aCA9PT0gMClcbiAgICB9XG4gICAgcmV0dXJuIHtoaXQsIGlzU3VuaywgZ2V0UG9zaXRpb25zfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGlwOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"opponentBoard\", function() { return /* binding */ opponentBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoard\", function() { return /* binding */ selfBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoardDiv\", function() { return /* binding */ selfBoardDiv; });\n\n// CONCATENATED MODULE: ./src/modules/Factories/GameBoard.js\nconst Ship = __webpack_require__(1);\n\nfunction GameBoard() {\n    const boardArray = [];\n    const ships = [];\n\n    // Initialize an empty board of size 10 * 10\n    for(let i = 0; i < 100; i ++) {\n        boardArray.push(undefined);\n    }\n\n    const placeShip = (index, positions) => {\n        if(positions.every(position => boardArray[position] === undefined)) {\n            const ship = Ship(positions);\n            positions.forEach(position => boardArray[position] = index);\n            ships.push(ship);\n        } else {\n            console.log(\"one or more positions are occupied\")\n        }\n    }\n\n    const removeAllShips = () => {\n        for(let i = 0; i < 100; i ++) {\n            boardArray.push(undefined);\n        }\n    }\n\n    const updateShip = (index, oldPositions, newPositions) => {\n        // remove ship from old position\n        oldPositions.forEach(position => boardArray[position] = undefined);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // replace old ship with new ship\n        ships[index] = Ship(newPositions);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // place this ship on the boardArray\n        newPositions.forEach(position => boardArray[position] = index);\n    }\n\n    const receiveAttack = (position) => {\n        if(boardArray[position] === undefined) {\n            boardArray[position] = 'miss';\n        } else if (boardArray[position] !== 'miss' && boardArray[position] !== 'hit'){\n            const index = boardArray[position];\n            const hitShip = ships[index];\n            hitShip.hit(position);\n            boardArray[position] = 'hit';\n        }\n    }\n\n    const allShipsSunk = () => {\n        return ships.every(ship => ship.isSunk());\n    }\n\n    return {\n        boardArray,\n        ships,\n        placeShip,\n        removeAllShips,\n        updateShip,\n        receiveAttack,\n        allShipsSunk\n    }\n}\n\n/* harmony default export */ var Factories_GameBoard = (GameBoard);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/BoardDisplay.js\nfunction renderBoard(boardArray, boardDiv) {\n\n    boardArray.forEach( (value, index = 0) => {\n        const cell = document.createElement('div');\n        cell.classList.add('cell');\n        cell.setAttribute('data-key', index);\n        boardDiv.appendChild(cell);\n    })\n}\n\n/* harmony default export */ var BoardDisplay = (renderBoard);\n// EXTERNAL MODULE: ./src/modules/Factories/Player.js\nvar Player = __webpack_require__(0);\nvar Player_default = /*#__PURE__*/__webpack_require__.n(Player);\n\n// CONCATENATED MODULE: ./src/modules/ComputerAttack.js\n\n\nfunction validatePosition(direction, hit, position) {\n    // check if the position is on the board\n    if(position < 0 || position > 99) return undefined;\n\n    // check if on the same row, because rows are wrapped\n    if(direction === 'left' || direction === 'right') {\n        const hitRow = Math.floor(hit / 10);\n        const positionRow = Math.floor(position / 10);\n        if(hitRow !== positionRow) return undefined;\n    }\n\n    // check if position had already been attacked\n    let nextPosition = position\n    let cellValue = selfBoard.boardArray[nextPosition];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        nextPosition = getPositionBasedOnHit(position, direction);\n        cellValue = selfBoard.boardArray[nextPosition];\n    }\n    return nextPosition;\n}\n\nfunction getPositionBasedOnHit(hit, direction) {\n    let position;\n    switch (direction) {\n        case 'up':\n            position = hit - 10;\n            break;\n\n        case 'down':\n            position = hit + 10;\n            break;\n\n        case 'left':\n            position = hit - 1;\n            break;\n\n        case 'right':\n            position = hit + 1;\n    }\n    return validatePosition(direction, hit, position);\n}\n\nfunction getRandomPosition() {\n    let position = Math.floor(Math.random() * 100);\n    let cellValue = selfBoard.boardArray[position];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        position = Math.floor(Math.random() * 100);\n        cellValue = selfBoard.boardArray[position];\n    }\n    return position;\n}\n\nfunction ComputerAttack() {\n    let hit;\n    let directions = ['up', 'down', 'left', 'right'];\n\n    const updateHits = (position) => {\n        hit = position;\n    }\n\n    const updateMiss = () => {\n        if(!hit) return;\n        directions.shift();\n\n        // If we've checked in all directions, setup variables for next hit\n        if(directions.length === 0) {\n            hit = undefined;\n            directions = ['up', 'down', 'left', 'right'];\n        }\n    }\n\n    const getComputerAttackPosition = () => {\n        if(hit) {\n            console.log('inside ' + hit + directions);\n\n            // get a valid position i.e on board and on same column for vertical ships\n            let position =  getPositionBasedOnHit(hit, directions[0]);\n            while (!position) {\n                directions.shift();\n                if(directions.length === 0) {\n                    hit = undefined;\n                    directions = ['up', 'down', 'left', 'right'];\n                    return getRandomPosition();\n                }\n                position = getPositionBasedOnHit(hit, directions[0]);\n            }\n            return position;\n        }\n        return getRandomPosition();\n    }\n\n    return {getComputerAttackPosition, updateMiss, updateHits};\n}\n\n/* harmony default export */ var modules_ComputerAttack = (ComputerAttack);\n// CONCATENATED MODULE: ./src/modules/GameLoop.js\n\n\n\n\nconst human = Player_default()();\nconst computer = Player_default()();\nconst computerAttack = modules_ComputerAttack();\n\nfunction playRound(e) {\n    if(selfBoard.allShipsSunk() || opponentBoard.allShipsSunk()) {\n        const winner = opponentBoard.allShipsSunk() ? 'human' : 'computer';\n        console.log(`winner is ${winner}`);\n        return;\n    }\n    // human's attack on computer\n    let cell = e.target;\n    let position = cell.getAttribute('data-key');\n\n    // Don't play round if user attacks already attacked position\n    if([...cell.classList].includes('hit') || [...cell.classList].includes('miss')) return;\n\n    attack(human, opponentBoard, cell, position);\n\n    // computer's attack on human\n    position = computerAttack.getComputerAttackPosition();\n    console.log(position);\n    cell = selfBoardDiv.querySelector(`div[data-key=\"${position}\"]`);\n\n    const computerResult = attack(computer, selfBoard, cell, position);\n    console.log(computerResult);\n\n    // Update hits and misses so computer can make intelligent guesses next time\n    if(computerResult === 'hit') {\n        computerAttack.updateHits(position);\n    } else {\n        computerAttack.updateMiss(position);\n    }\n}\n\nfunction attack(player, board, cell, position){\n    player.attack(board, position);\n    const result = board.boardArray[position];\n    if (result === 'miss') {\n        cell.classList.add('miss');\n    } else if (result === 'hit'){\n        cell.classList.add('hit');\n    }\n    return result;\n}\n\n/* harmony default export */ var GameLoop = (playRound);\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipPlacement.js\nfunction checkValidHorizontalPosition(unaivalablePositions, position, size) {\n    const row = Math.floor(position / 10);\n    const end = (row + 1) * 10;\n\n    // checking if last position will be in the same row\n    if(position + size - 1 >= end) {\n        return false\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position ++;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction checkValidVerticalPosition(unaivalablePositions, position, size) {\n    const col = position % 10;\n    const end = col + 90;\n\n    // checking if last position will be in the same column\n    if(position + (size - 1) * 10 > end) {\n        return false;\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position += 10;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction isvalidPosition(unaivalablePositions ,position, size, orientation) {\n    if(unaivalablePositions.includes(position)) return false;\n\n    if(orientation === 'horizontal') {\n        return checkValidHorizontalPosition(unaivalablePositions, position, size);\n    } else {\n        return checkValidVerticalPosition(unaivalablePositions, position, size);\n    }\n}\n\nfunction getValidPosition(unavailablePositions, size, orientation) {\n    let position = Math.floor(Math.random() * 100);\n    while(!isvalidPosition(unavailablePositions, position, size, orientation))\n    {\n        position = Math.floor(Math.random() * 100);\n    }\n    return position;\n}\n\nfunction makeShips() {\n    const unavailablePositions = [];\n    const ships = [];\n    const orientations = [];\n    // let's make 5 ships of sizes 1 to 5\n    for(let size = 1; size <= 5; size ++) {\n        let orientation = size % 2 ? 'vertical' : 'horizontal';\n        orientations.push(orientation);\n\n        let ship = [];\n        let position = getValidPosition(unavailablePositions, size, orientation);\n        for(let i = 0; i < size; i ++) {\n            ship.push(position);\n            unavailablePositions.push(position);\n            if(orientation === 'vertical') {\n                position += 10;\n            } else {\n                position ++;\n            }\n        }\n        ships.push(ship);\n    }\n    console.log(ships, orientations);\n    return {ships, orientations};\n}\n\nconst shipPlacement = {\n    randomPlacement(board) {\n        const {ships, orientations} = makeShips();\n        ships.forEach((ship, index= 0 )=> {\n            board.placeShip(index, ship);\n        });\n        return {ships, orientations};\n    },\n    removeShips(board) {\n        board.removeAllShips();\n    }\n}\n\n/* harmony default export */ var ShipPlacement = (shipPlacement);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivPlacement.js\n\n\nfunction styleShip(ship, orientation, start, end) {\n    if(orientation === 'vertical') {\n        ship.setAttribute('data-top', start);\n        ship.setAttribute('data-bottom', end);\n    } else {\n        ship.setAttribute('data-left', start);\n        ship.setAttribute('data-right', end);\n    }\n    const topOffset = Math.floor(start/ 10);\n    const leftOffset = start % 10;\n\n    ship.style.top = `${topOffset * 42}px`;\n    ship.style.left = `${leftOffset * 42}px`;\n}\n\nfunction makeShipDiv(orientation, shipNum, length) {\n    const div = document.createElement('div');\n    div.classList.add('ship');\n    div.draggable = true;\n    div.classList.add(orientation);\n    div.setAttribute('data-ship', shipNum);\n    div.setAttribute('data-length', length);\n    if(orientation === 'vertical') {\n        div.style.width = '40px';\n        div.style.height = `${40 * length}px`;\n    } else {\n        div.style.height = '40px';\n        div.style.width = `${40 * length}px`;\n    }\n    return div;\n}\n\nfunction placeShipDivs(container, shipNum, orientation, length, start, end) {\n    const ship = makeShipDiv(orientation, shipNum, length);\n    styleShip(ship, orientation, start, end);\n    container.appendChild(ship);\n}\n\nfunction placeAllShipDivs(ships, orientations) {\n    ships.forEach((ship, index= 0 )=> {\n        const length = ship.length;\n        const start = ship[0];\n        const end = ship[length - 1];\n        placeShipDivs(selfBoardDiv, `${index}`, orientations[index], length, start, end);\n    });\n}\n\nfunction removeAllShipDivs() {\n    const shipDivs = document.querySelectorAll('.ship');\n    shipDivs.forEach(shipDiv => selfBoardDiv.removeChild(shipDiv));\n}\n\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovementHandler.js\n\n\n\nfunction moveShipDiv(ship, cell, orientation, length) {\n    if(orientation === 'vertical') {\n        const newBottom = cell.getAttribute('data-key');\n        const newTop = newBottom - (length - 1) * 10;\n        if(newTop < 0) return;\n\n        styleShip(ship, 'vertical', newTop, newBottom);\n    } else {\n        const newRight = cell.getAttribute('data-key');\n        const row = Math.floor(newRight / 10);\n        const newLeft = newRight - (length - 1);\n        if(newLeft < row * 10) return;\n\n        styleShip(ship, 'horizontal', newLeft, newRight);\n    }\n}\n\nfunction getPositionsFromShipDiv(orientation, length, end) {\n    const positions = [];\n    let position = end;\n\n    const decrement = orientation === 'vertical' ? 10 : 1;\n\n    for(let i = 0; i < length; i ++) {\n        positions.push(position);\n        position -= decrement;\n    }\n    return positions;\n}\n\nfunction areValidPositions(newPositions, oldPositions) {\n    return newPositions.every(newPosition => {\n        // each position must either be empty or one of previous positions\n        return (selfBoard.boardArray[newPosition] === undefined\n                || oldPositions.includes(newPosition)\n        )\n    });\n}\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovement.js\n\n\n\nfunction addDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.addEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.addEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.addEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.addEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.addEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.addEventListener('drop', dragDrop));\n}\n\nfunction removeDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.removeEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.removeEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.removeEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.removeEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.removeEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.removeEventListener('drop', dragDrop));\n}\n\n// Dragging functions\n\nfunction dragStart(e) {\n    console.log('start');\n    const shipNum = this.getAttribute('data-ship');\n    e.dataTransfer.setData(\"text\", shipNum);\n    setTimeout(() => this.classList.add('hidden'), 0);\n}\n\nfunction dragEnd() {\n    console.log('end');\n    this.classList.remove('hidden');\n}\n\nfunction dragOver(e) {\n    console.log('over');\n    e.preventDefault();\n}\n\nfunction dragEnter() {\n    console.log('enter');\n    this.classList.add('hovered');\n}\n\nfunction dragLeave() {\n    console.log('leave');\n    this.className = 'cell';\n}\n\nfunction dragDrop(e) {\n    console.log('drop');\n    e.preventDefault();\n    console.log(e);\n    const data = e.dataTransfer.getData(\"text\");\n    console.log(data);\n    this.className = 'cell';\n    const ship = selfBoardDiv.querySelector(`.ship[data-ship='${data}']`);\n    const cell = this;\n    console.log(ship, cell);\n    handleDrop(ship, cell);\n}\n\nfunction handleDrop(ship, cell) {\n    // move the div\n    const orientation = [...ship.classList].includes('horizontal') ? 'horizontal' : 'vertical';\n    const length = ship.getAttribute('data-length');\n\n    // get old end and positions\n    const oldEnd = orientation === 'horizontal' ?\n        parseInt(ship.getAttribute('data-right'))\n        : parseInt(ship.getAttribute('data-bottom'));\n    const oldPositions = getPositionsFromShipDiv(orientation, length, oldEnd);\n    console.log(oldEnd, oldPositions);\n\n    // check if moving this div will cause any of the positions to overlap\n    const newEnd = parseInt(cell.getAttribute('data-key'));\n    const newPositions = getPositionsFromShipDiv(orientation, length, newEnd);\n\n    if(!areValidPositions(newPositions, oldPositions)) return;\n    console.log(newEnd, newPositions);\n\n    moveShipDiv(ship, cell, orientation, length);\n\n    const shipIndex = parseInt(ship.getAttribute('data-ship'));\n    console.log(shipIndex, oldPositions, newPositions);\n    selfBoard.updateShip(shipIndex, oldPositions, newPositions);\n}\n\n\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\nconst selfBoard = Factories_GameBoard();\nconst opponentBoard = Factories_GameBoard();\n\nconst selfBoardDiv = document.querySelector('#self');\nconst opponentBoardDiv = document.querySelector('#opponent');\n/******************************************************************************************\n * placement of ships\n *******************************************************************************************/\nlet {ships: src_ships, orientations: src_orientations} = ShipPlacement.randomPlacement(selfBoard);\nplaceAllShipDivs(src_ships, src_orientations);\n\nShipPlacement.randomPlacement(opponentBoard, opponentBoardDiv);\n\nconsole.log(selfBoard);\nconsole.log(opponentBoard);\n\n/******************************************************************************************\n * display boards after ships are placed\n *******************************************************************************************/\n\nBoardDisplay(selfBoard.boardArray, selfBoardDiv);\nBoardDisplay(opponentBoard.boardArray, opponentBoardDiv);\n\naddDragEventListeners();\n\n\n/******************************************************************************************\n * handle events for randomize placement, reset game, start game\n *******************************************************************************************/\nconst randomButton = document.querySelector('#randomButton');\nrandomButton.addEventListener('click', () => {\n    ShipPlacement.removeShips(selfBoard);\n    removeAllShipDivs();\n\n    let res = ShipPlacement.randomPlacement(selfBoard);\n    placeAllShipDivs(res.ships, res.orientations);\n});\n\nconst startButton = document.querySelector('#startButton');\nstartButton.addEventListener('click', () => {\n    opponentBoardDiv.addEventListener('click', GameLoop);\n    removeDragEventListeners();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkLmpzPzkyY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheS5qcz8yYzIyIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0NvbXB1dGVyQXR0YWNrLmpzPzY2NmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvR2FtZUxvb3AuanM/M2Y4YSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudC5qcz9mNzQ1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50LmpzPzE2YTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudEhhbmRsZXIuanM/Y2UyMSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcERpdk1vdmVtZW50LmpzP2UyMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsYUFBYSxtQkFBTyxDQUFDLENBQVE7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ3NDO0FBQ1g7O0FBRS9GLGtCQUFrQixtQkFBUztBQUMzQixzQkFBc0IsbUJBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUsseUJBQWMsbUJBQUMsR0FBRyxhQUFhO0FBQ3pDLGdCQUFnQixDQUFDLFNBQUssRUFBRSxnQkFBWTs7QUFFcEMsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1gsWUFBVzs7QUFFWCxxQkFBcUI7QUFDMEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakIsSUFBSSxpQkFBaUI7O0FBRXJCLGNBQWMsYUFBYTtBQUMzQixJQUFJLGdCQUFnQjtBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUztBQUN4RCxJQUFJLHdCQUF3QjtBQUM1QixDQUFDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTaGlwID0gcmVxdWlyZSgnLi9TaGlwJyk7XG5cbmZ1bmN0aW9uIEdhbWVCb2FyZCgpIHtcbiAgICBjb25zdCBib2FyZEFycmF5ID0gW107XG4gICAgY29uc3Qgc2hpcHMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgYW4gZW1wdHkgYm9hcmQgb2Ygc2l6ZSAxMCAqIDEwXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDEwMDsgaSArKykge1xuICAgICAgICBib2FyZEFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwbGFjZVNoaXAgPSAoaW5kZXgsIHBvc2l0aW9ucykgPT4ge1xuICAgICAgICBpZihwb3NpdGlvbnMuZXZlcnkocG9zaXRpb24gPT4gYm9hcmRBcnJheVtwb3NpdGlvbl0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaXAgPSBTaGlwKHBvc2l0aW9ucyk7XG4gICAgICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9IGluZGV4KTtcbiAgICAgICAgICAgIHNoaXBzLnB1c2goc2hpcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uZSBvciBtb3JlIHBvc2l0aW9ucyBhcmUgb2NjdXBpZWRcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZUFsbFNoaXBzID0gKCkgPT4ge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTAwOyBpICsrKSB7XG4gICAgICAgICAgICBib2FyZEFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZVNoaXAgPSAoaW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSBzaGlwIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIG9sZFBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IGJvYXJkQXJyYXlbcG9zaXRpb25dID0gdW5kZWZpbmVkKTtcblxuICAgICAgICBzaGlwcy5mb3JFYWNoKHNoaXAgPT4gY29uc29sZS5sb2coc2hpcC5nZXRQb3NpdGlvbnMoKSkpO1xuICAgICAgICAvLyByZXBsYWNlIG9sZCBzaGlwIHdpdGggbmV3IHNoaXBcbiAgICAgICAgc2hpcHNbaW5kZXhdID0gU2hpcChuZXdQb3NpdGlvbnMpO1xuXG4gICAgICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBjb25zb2xlLmxvZyhzaGlwLmdldFBvc2l0aW9ucygpKSk7XG4gICAgICAgIC8vIHBsYWNlIHRoaXMgc2hpcCBvbiB0aGUgYm9hcmRBcnJheVxuICAgICAgICBuZXdQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9IGluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNlaXZlQXR0YWNrID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmKGJvYXJkQXJyYXlbcG9zaXRpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJvYXJkQXJyYXlbcG9zaXRpb25dID0gJ21pc3MnO1xuICAgICAgICB9IGVsc2UgaWYgKGJvYXJkQXJyYXlbcG9zaXRpb25dICE9PSAnbWlzcycgJiYgYm9hcmRBcnJheVtwb3NpdGlvbl0gIT09ICdoaXQnKXtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBjb25zdCBoaXRTaGlwID0gc2hpcHNbaW5kZXhdO1xuICAgICAgICAgICAgaGl0U2hpcC5oaXQocG9zaXRpb24pO1xuICAgICAgICAgICAgYm9hcmRBcnJheVtwb3NpdGlvbl0gPSAnaGl0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFsbFNoaXBzU3VuayA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNoaXBzLmV2ZXJ5KHNoaXAgPT4gc2hpcC5pc1N1bmsoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9hcmRBcnJheSxcbiAgICAgICAgc2hpcHMsXG4gICAgICAgIHBsYWNlU2hpcCxcbiAgICAgICAgcmVtb3ZlQWxsU2hpcHMsXG4gICAgICAgIHVwZGF0ZVNoaXAsXG4gICAgICAgIHJlY2VpdmVBdHRhY2ssXG4gICAgICAgIGFsbFNoaXBzU3Vua1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2FtZUJvYXJkO1xuIiwiZnVuY3Rpb24gcmVuZGVyQm9hcmQoYm9hcmRBcnJheSwgYm9hcmREaXYpIHtcblxuICAgIGJvYXJkQXJyYXkuZm9yRWFjaCggKHZhbHVlLCBpbmRleCA9IDApID0+IHtcbiAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ2NlbGwnKTtcbiAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2RhdGEta2V5JywgaW5kZXgpO1xuICAgICAgICBib2FyZERpdi5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJCb2FyZDsiLCJpbXBvcnQge3NlbGZCb2FyZH0gZnJvbSAnLi4vaW5kZXgnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aW9uKGRpcmVjdGlvbiwgaGl0LCBwb3NpdGlvbikge1xuICAgIC8vIGNoZWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvbiB0aGUgYm9hcmRcbiAgICBpZihwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiA5OSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIC8vIGNoZWNrIGlmIG9uIHRoZSBzYW1lIHJvdywgYmVjYXVzZSByb3dzIGFyZSB3cmFwcGVkXG4gICAgaWYoZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IGhpdFJvdyA9IE1hdGguZmxvb3IoaGl0IC8gMTApO1xuICAgICAgICBjb25zdCBwb3NpdGlvblJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyAxMCk7XG4gICAgICAgIGlmKGhpdFJvdyAhPT0gcG9zaXRpb25Sb3cpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgcG9zaXRpb24gaGFkIGFscmVhZHkgYmVlbiBhdHRhY2tlZFxuICAgIGxldCBuZXh0UG9zaXRpb24gPSBwb3NpdGlvblxuICAgIGxldCBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXh0UG9zaXRpb25dO1xuICAgIHdoaWxlKGNlbGxWYWx1ZSA9PT0gJ21pc3MnIHx8IGNlbGxWYWx1ZSA9PT0gJ2hpdCcpIHtcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gZ2V0UG9zaXRpb25CYXNlZE9uSGl0KHBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXh0UG9zaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkJhc2VkT25IaXQoaGl0LCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndXAnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgLSAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgKyAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIGhpdCwgcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21Qb3NpdGlvbigpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIGxldCBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgd2hpbGUoY2VsbFZhbHVlID09PSAnbWlzcycgfHwgY2VsbFZhbHVlID09PSAnaGl0Jykge1xuICAgICAgICBwb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgIGNlbGxWYWx1ZSA9IHNlbGZCb2FyZC5ib2FyZEFycmF5W3Bvc2l0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBDb21wdXRlckF0dGFjaygpIHtcbiAgICBsZXQgaGl0O1xuICAgIGxldCBkaXJlY3Rpb25zID0gWyd1cCcsICdkb3duJywgJ2xlZnQnLCAncmlnaHQnXTtcblxuICAgIGNvbnN0IHVwZGF0ZUhpdHMgPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgaGl0ID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlTWlzcyA9ICgpID0+IHtcbiAgICAgICAgaWYoIWhpdCkgcmV0dXJuO1xuICAgICAgICBkaXJlY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgY2hlY2tlZCBpbiBhbGwgZGlyZWN0aW9ucywgc2V0dXAgdmFyaWFibGVzIGZvciBuZXh0IGhpdFxuICAgICAgICBpZihkaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGlyZWN0aW9ucyA9IFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnZXRDb21wdXRlckF0dGFja1Bvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZihoaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbnNpZGUgJyArIGhpdCArIGRpcmVjdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBnZXQgYSB2YWxpZCBwb3NpdGlvbiBpLmUgb24gYm9hcmQgYW5kIG9uIHNhbWUgY29sdW1uIGZvciB2ZXJ0aWNhbCBzaGlwc1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gIGdldFBvc2l0aW9uQmFzZWRPbkhpdChoaXQsIGRpcmVjdGlvbnNbMF0pO1xuICAgICAgICAgICAgd2hpbGUgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBoaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZG9tUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkJhc2VkT25IaXQoaGl0LCBkaXJlY3Rpb25zWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0UmFuZG9tUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2dldENvbXB1dGVyQXR0YWNrUG9zaXRpb24sIHVwZGF0ZU1pc3MsIHVwZGF0ZUhpdHN9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wdXRlckF0dGFjazsiLCJpbXBvcnQgUGxheWVyIGZyb20gJy4vRmFjdG9yaWVzL1BsYXllcic7XG5pbXBvcnQge3NlbGZCb2FyZCwgb3Bwb25lbnRCb2FyZCwgc2VsZkJvYXJkRGl2fSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgQ29tcHV0ZXJBdHRhY2sgZnJvbSAnLi9Db21wdXRlckF0dGFjayc7XG5cbmNvbnN0IGh1bWFuID0gUGxheWVyKCk7XG5jb25zdCBjb21wdXRlciA9IFBsYXllcigpO1xuY29uc3QgY29tcHV0ZXJBdHRhY2sgPSBDb21wdXRlckF0dGFjaygpO1xuXG5mdW5jdGlvbiBwbGF5Um91bmQoZSkge1xuICAgIGlmKHNlbGZCb2FyZC5hbGxTaGlwc1N1bmsoKSB8fCBvcHBvbmVudEJvYXJkLmFsbFNoaXBzU3VuaygpKSB7XG4gICAgICAgIGNvbnN0IHdpbm5lciA9IG9wcG9uZW50Qm9hcmQuYWxsU2hpcHNTdW5rKCkgPyAnaHVtYW4nIDogJ2NvbXB1dGVyJztcbiAgICAgICAgY29uc29sZS5sb2coYHdpbm5lciBpcyAke3dpbm5lcn1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBodW1hbidzIGF0dGFjayBvbiBjb21wdXRlclxuICAgIGxldCBjZWxsID0gZS50YXJnZXQ7XG4gICAgbGV0IHBvc2l0aW9uID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Jyk7XG5cbiAgICAvLyBEb24ndCBwbGF5IHJvdW5kIGlmIHVzZXIgYXR0YWNrcyBhbHJlYWR5IGF0dGFja2VkIHBvc2l0aW9uXG4gICAgaWYoWy4uLmNlbGwuY2xhc3NMaXN0XS5pbmNsdWRlcygnaGl0JykgfHwgWy4uLmNlbGwuY2xhc3NMaXN0XS5pbmNsdWRlcygnbWlzcycpKSByZXR1cm47XG5cbiAgICBhdHRhY2soaHVtYW4sIG9wcG9uZW50Qm9hcmQsIGNlbGwsIHBvc2l0aW9uKTtcblxuICAgIC8vIGNvbXB1dGVyJ3MgYXR0YWNrIG9uIGh1bWFuXG4gICAgcG9zaXRpb24gPSBjb21wdXRlckF0dGFjay5nZXRDb21wdXRlckF0dGFja1Bvc2l0aW9uKCk7XG4gICAgY29uc29sZS5sb2cocG9zaXRpb24pO1xuICAgIGNlbGwgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvcihgZGl2W2RhdGEta2V5PVwiJHtwb3NpdGlvbn1cIl1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVyUmVzdWx0ID0gYXR0YWNrKGNvbXB1dGVyLCBzZWxmQm9hcmQsIGNlbGwsIHBvc2l0aW9uKTtcbiAgICBjb25zb2xlLmxvZyhjb21wdXRlclJlc3VsdCk7XG5cbiAgICAvLyBVcGRhdGUgaGl0cyBhbmQgbWlzc2VzIHNvIGNvbXB1dGVyIGNhbiBtYWtlIGludGVsbGlnZW50IGd1ZXNzZXMgbmV4dCB0aW1lXG4gICAgaWYoY29tcHV0ZXJSZXN1bHQgPT09ICdoaXQnKSB7XG4gICAgICAgIGNvbXB1dGVyQXR0YWNrLnVwZGF0ZUhpdHMocG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXB1dGVyQXR0YWNrLnVwZGF0ZU1pc3MocG9zaXRpb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNrKHBsYXllciwgYm9hcmQsIGNlbGwsIHBvc2l0aW9uKXtcbiAgICBwbGF5ZXIuYXR0YWNrKGJvYXJkLCBwb3NpdGlvbik7XG4gICAgY29uc3QgcmVzdWx0ID0gYm9hcmQuYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgaWYgKHJlc3VsdCA9PT0gJ21pc3MnKSB7XG4gICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnbWlzcycpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAnaGl0Jyl7XG4gICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnaGl0Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXlSb3VuZDsiLCJmdW5jdGlvbiBjaGVja1ZhbGlkSG9yaXpvbnRhbFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSkge1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyAxMCk7XG4gICAgY29uc3QgZW5kID0gKHJvdyArIDEpICogMTA7XG5cbiAgICAvLyBjaGVja2luZyBpZiBsYXN0IHBvc2l0aW9uIHdpbGwgYmUgaW4gdGhlIHNhbWUgcm93XG4gICAgaWYocG9zaXRpb24gKyBzaXplIC0gMSA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIHBvc2l0aW9ucyB3aXRoIHRoaXMgc3RhcnRpbmcgcG9zaXRpb24gYXJlIGF2YWlsYWJsZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9uICsrO1xuICAgICAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZFZlcnRpY2FsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3QgY29sID0gcG9zaXRpb24gJSAxMDtcbiAgICBjb25zdCBlbmQgPSBjb2wgKyA5MDtcblxuICAgIC8vIGNoZWNraW5nIGlmIGxhc3QgcG9zaXRpb24gd2lsbCBiZSBpbiB0aGUgc2FtZSBjb2x1bW5cbiAgICBpZihwb3NpdGlvbiArIChzaXplIC0gMSkgKiAxMCA+IGVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIHBvc2l0aW9ucyB3aXRoIHRoaXMgc3RhcnRpbmcgcG9zaXRpb24gYXJlIGF2YWlsYWJsZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IDEwO1xuICAgICAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXN2YWxpZFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zICxwb3NpdGlvbiwgc2l6ZSwgb3JpZW50YXRpb24pIHtcbiAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcblxuICAgIGlmKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrVmFsaWRIb3Jpem9udGFsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tWYWxpZFZlcnRpY2FsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFZhbGlkUG9zaXRpb24odW5hdmFpbGFibGVQb3NpdGlvbnMsIHNpemUsIG9yaWVudGF0aW9uKSB7XG4gICAgbGV0IHBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB3aGlsZSghaXN2YWxpZFBvc2l0aW9uKHVuYXZhaWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSwgb3JpZW50YXRpb24pKVxuICAgIHtcbiAgICAgICAgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIG1ha2VTaGlwcygpIHtcbiAgICBjb25zdCB1bmF2YWlsYWJsZVBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHNoaXBzID0gW107XG4gICAgY29uc3Qgb3JpZW50YXRpb25zID0gW107XG4gICAgLy8gbGV0J3MgbWFrZSA1IHNoaXBzIG9mIHNpemVzIDEgdG8gNVxuICAgIGZvcihsZXQgc2l6ZSA9IDE7IHNpemUgPD0gNTsgc2l6ZSArKykge1xuICAgICAgICBsZXQgb3JpZW50YXRpb24gPSBzaXplICUgMiA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIG9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcblxuICAgICAgICBsZXQgc2hpcCA9IFtdO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBnZXRWYWxpZFBvc2l0aW9uKHVuYXZhaWxhYmxlUG9zaXRpb25zLCBzaXplLCBvcmllbnRhdGlvbik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgICAgICBzaGlwLnB1c2gocG9zaXRpb24pO1xuICAgICAgICAgICAgdW5hdmFpbGFibGVQb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICAgICAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDEwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGlwcy5wdXNoKHNoaXApO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhzaGlwcywgb3JpZW50YXRpb25zKTtcbiAgICByZXR1cm4ge3NoaXBzLCBvcmllbnRhdGlvbnN9O1xufVxuXG5jb25zdCBzaGlwUGxhY2VtZW50ID0ge1xuICAgIHJhbmRvbVBsYWNlbWVudChib2FyZCkge1xuICAgICAgICBjb25zdCB7c2hpcHMsIG9yaWVudGF0aW9uc30gPSBtYWtlU2hpcHMoKTtcbiAgICAgICAgc2hpcHMuZm9yRWFjaCgoc2hpcCwgaW5kZXg9IDAgKT0+IHtcbiAgICAgICAgICAgIGJvYXJkLnBsYWNlU2hpcChpbmRleCwgc2hpcCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge3NoaXBzLCBvcmllbnRhdGlvbnN9O1xuICAgIH0sXG4gICAgcmVtb3ZlU2hpcHMoYm9hcmQpIHtcbiAgICAgICAgYm9hcmQucmVtb3ZlQWxsU2hpcHMoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoaXBQbGFjZW1lbnQ7XG4iLCJpbXBvcnQge3NlbGZCb2FyZERpdn0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIHN0eWxlU2hpcChzaGlwLCBvcmllbnRhdGlvbiwgc3RhcnQsIGVuZCkge1xuICAgIGlmKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHNoaXAuc2V0QXR0cmlidXRlKCdkYXRhLXRvcCcsIHN0YXJ0KTtcbiAgICAgICAgc2hpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm90dG9tJywgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1sZWZ0Jywgc3RhcnQpO1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1yaWdodCcsIGVuZCk7XG4gICAgfVxuICAgIGNvbnN0IHRvcE9mZnNldCA9IE1hdGguZmxvb3Ioc3RhcnQvIDEwKTtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gc3RhcnQgJSAxMDtcblxuICAgIHNoaXAuc3R5bGUudG9wID0gYCR7dG9wT2Zmc2V0ICogNDJ9cHhgO1xuICAgIHNoaXAuc3R5bGUubGVmdCA9IGAke2xlZnRPZmZzZXQgKiA0Mn1weGA7XG59XG5cbmZ1bmN0aW9uIG1ha2VTaGlwRGl2KG9yaWVudGF0aW9uLCBzaGlwTnVtLCBsZW5ndGgpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCgnc2hpcCcpO1xuICAgIGRpdi5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKG9yaWVudGF0aW9uKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLXNoaXAnLCBzaGlwTnVtKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLWxlbmd0aCcsIGxlbmd0aCk7XG4gICAgaWYob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzQwcHgnO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7NDAgKiBsZW5ndGh9cHhgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnNDBweCc7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAkezQwICogbGVuZ3RofXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gcGxhY2VTaGlwRGl2cyhjb250YWluZXIsIHNoaXBOdW0sIG9yaWVudGF0aW9uLCBsZW5ndGgsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBzaGlwID0gbWFrZVNoaXBEaXYob3JpZW50YXRpb24sIHNoaXBOdW0sIGxlbmd0aCk7XG4gICAgc3R5bGVTaGlwKHNoaXAsIG9yaWVudGF0aW9uLCBzdGFydCwgZW5kKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc2hpcCk7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQWxsU2hpcERpdnMoc2hpcHMsIG9yaWVudGF0aW9ucykge1xuICAgIHNoaXBzLmZvckVhY2goKHNoaXAsIGluZGV4PSAwICk9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNoaXAubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGFydCA9IHNoaXBbMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHNoaXBbbGVuZ3RoIC0gMV07XG4gICAgICAgIHBsYWNlU2hpcERpdnMoc2VsZkJvYXJkRGl2LCBgJHtpbmRleH1gLCBvcmllbnRhdGlvbnNbaW5kZXhdLCBsZW5ndGgsIHN0YXJ0LCBlbmQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxTaGlwRGl2cygpIHtcbiAgICBjb25zdCBzaGlwRGl2cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaGlwJyk7XG4gICAgc2hpcERpdnMuZm9yRWFjaChzaGlwRGl2ID0+IHNlbGZCb2FyZERpdi5yZW1vdmVDaGlsZChzaGlwRGl2KSk7XG59XG5cbmV4cG9ydCB7c3R5bGVTaGlwLCBwbGFjZUFsbFNoaXBEaXZzLCByZW1vdmVBbGxTaGlwRGl2c307XG4iLCJpbXBvcnQge3N0eWxlU2hpcH0gZnJvbSAnLi9TaGlwRGl2UGxhY2VtZW50JztcbmltcG9ydCB7c2VsZkJvYXJkfSBmcm9tICcuLi8uLi9pbmRleCc7XG5cbmZ1bmN0aW9uIG1vdmVTaGlwRGl2KHNoaXAsIGNlbGwsIG9yaWVudGF0aW9uLCBsZW5ndGgpIHtcbiAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBjb25zdCBuZXdCb3R0b20gPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKTtcbiAgICAgICAgY29uc3QgbmV3VG9wID0gbmV3Qm90dG9tIC0gKGxlbmd0aCAtIDEpICogMTA7XG4gICAgICAgIGlmKG5ld1RvcCA8IDApIHJldHVybjtcblxuICAgICAgICBzdHlsZVNoaXAoc2hpcCwgJ3ZlcnRpY2FsJywgbmV3VG9wLCBuZXdCb3R0b20pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Jyk7XG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IobmV3UmlnaHQgLyAxMCk7XG4gICAgICAgIGNvbnN0IG5ld0xlZnQgPSBuZXdSaWdodCAtIChsZW5ndGggLSAxKTtcbiAgICAgICAgaWYobmV3TGVmdCA8IHJvdyAqIDEwKSByZXR1cm47XG5cbiAgICAgICAgc3R5bGVTaGlwKHNoaXAsICdob3Jpem9udGFsJywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYob3JpZW50YXRpb24sIGxlbmd0aCwgZW5kKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgbGV0IHBvc2l0aW9uID0gZW5kO1xuXG4gICAgY29uc3QgZGVjcmVtZW50ID0gb3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyAxMCA6IDE7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gLT0gZGVjcmVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiBhcmVWYWxpZFBvc2l0aW9ucyhuZXdQb3NpdGlvbnMsIG9sZFBvc2l0aW9ucykge1xuICAgIHJldHVybiBuZXdQb3NpdGlvbnMuZXZlcnkobmV3UG9zaXRpb24gPT4ge1xuICAgICAgICAvLyBlYWNoIHBvc2l0aW9uIG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIG9uZSBvZiBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgcmV0dXJuIChzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXdQb3NpdGlvbl0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHx8IG9sZFBvc2l0aW9ucy5pbmNsdWRlcyhuZXdQb3NpdGlvbilcbiAgICAgICAgKVxuICAgIH0pO1xufVxuXG5leHBvcnQgIHttb3ZlU2hpcERpdiwgZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYsIGFyZVZhbGlkUG9zaXRpb25zfTsiLCJpbXBvcnQge3NlbGZCb2FyZCwgc2VsZkJvYXJkRGl2fSBmcm9tICcuLi8uLi9pbmRleCc7XG5pbXBvcnQge2FyZVZhbGlkUG9zaXRpb25zLCBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdiwgbW92ZVNoaXBEaXZ9IGZyb20gJy4vU2hpcERpdk1vdmVtZW50SGFuZGxlcic7XG5cbmZ1bmN0aW9uIGFkZERyYWdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaGlwcyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcCcpO1xuICAgIGNvbnN0IGNlbGxzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJyk7XG4gICAgLy8gZHJhZ2dhYmxlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGRyYWdTdGFydCkpO1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBkcmFnRW5kKSk7XG5cbiAgICAvLyBjZWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ092ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBkcmFnRW50ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgZHJhZ0Ryb3ApKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHNoaXBzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaGlwJyk7XG4gICAgY29uc3QgY2VsbHMgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcbiAgICAvLyBkcmFnZ2FibGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IHNoaXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KSk7XG4gICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IHNoaXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGRyYWdFbmQpKTtcblxuICAgIC8vIGNlbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBkcmFnT3ZlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGRyYWdFbnRlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGRyYWdMZWF2ZSkpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBkcmFnRHJvcCkpO1xufVxuXG4vLyBEcmFnZ2luZyBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICBjb25zb2xlLmxvZygnc3RhcnQnKTtcbiAgICBjb25zdCBzaGlwTnVtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2hpcCcpO1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0XCIsIHNoaXBOdW0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGRyYWdFbmQoKSB7XG4gICAgY29uc29sZS5sb2coJ2VuZCcpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIGRyYWdPdmVyKGUpIHtcbiAgICBjb25zb2xlLmxvZygnb3ZlcicpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gZHJhZ0VudGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdlbnRlcicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaG92ZXJlZCcpO1xufVxuXG5mdW5jdGlvbiBkcmFnTGVhdmUoKSB7XG4gICAgY29uc29sZS5sb2coJ2xlYXZlJyk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSAnY2VsbCc7XG59XG5cbmZ1bmN0aW9uIGRyYWdEcm9wKGUpIHtcbiAgICBjb25zb2xlLmxvZygnZHJvcCcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgICBjb25zdCBkYXRhID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIik7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSAnY2VsbCc7XG4gICAgY29uc3Qgc2hpcCA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yKGAuc2hpcFtkYXRhLXNoaXA9JyR7ZGF0YX0nXWApO1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzO1xuICAgIGNvbnNvbGUubG9nKHNoaXAsIGNlbGwpO1xuICAgIGhhbmRsZURyb3Aoc2hpcCwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURyb3Aoc2hpcCwgY2VsbCkge1xuICAgIC8vIG1vdmUgdGhlIGRpdlxuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gWy4uLnNoaXAuY2xhc3NMaXN0XS5pbmNsdWRlcygnaG9yaXpvbnRhbCcpID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICBjb25zdCBsZW5ndGggPSBzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1sZW5ndGgnKTtcblxuICAgIC8vIGdldCBvbGQgZW5kIGFuZCBwb3NpdGlvbnNcbiAgICBjb25zdCBvbGRFbmQgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmlnaHQnKSlcbiAgICAgICAgOiBwYXJzZUludChzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1ib3R0b20nKSk7XG4gICAgY29uc3Qgb2xkUG9zaXRpb25zID0gZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYob3JpZW50YXRpb24sIGxlbmd0aCwgb2xkRW5kKTtcbiAgICBjb25zb2xlLmxvZyhvbGRFbmQsIG9sZFBvc2l0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBpZiBtb3ZpbmcgdGhpcyBkaXYgd2lsbCBjYXVzZSBhbnkgb2YgdGhlIHBvc2l0aW9ucyB0byBvdmVybGFwXG4gICAgY29uc3QgbmV3RW5kID0gcGFyc2VJbnQoY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5JykpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2KG9yaWVudGF0aW9uLCBsZW5ndGgsIG5ld0VuZCk7XG5cbiAgICBpZighYXJlVmFsaWRQb3NpdGlvbnMobmV3UG9zaXRpb25zLCBvbGRQb3NpdGlvbnMpKSByZXR1cm47XG4gICAgY29uc29sZS5sb2cobmV3RW5kLCBuZXdQb3NpdGlvbnMpO1xuXG4gICAgbW92ZVNoaXBEaXYoc2hpcCwgY2VsbCwgb3JpZW50YXRpb24sIGxlbmd0aCk7XG5cbiAgICBjb25zdCBzaGlwSW5kZXggPSBwYXJzZUludChzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1zaGlwJykpO1xuICAgIGNvbnNvbGUubG9nKHNoaXBJbmRleCwgb2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpO1xuICAgIHNlbGZCb2FyZC51cGRhdGVTaGlwKHNoaXBJbmRleCwgb2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpO1xufVxuXG5leHBvcnQge2FkZERyYWdFdmVudExpc3RlbmVycywgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzfTtcbiIsImltcG9ydCBHYW1lQm9hcmQgZnJvbSAnLi9tb2R1bGVzL0ZhY3Rvcmllcy9HYW1lQm9hcmQnO1xuaW1wb3J0IHJlbmRlckJvYXJkIGZyb20gJy4vbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vQm9hcmREaXNwbGF5JztcbmltcG9ydCBwbGF5Um91bmQgZnJvbSAnLi9tb2R1bGVzL0dhbWVMb29wJztcbmltcG9ydCBzaGlwUGxhY2VtZW50IGZyb20gJy4vbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudCc7XG5pbXBvcnQge2FkZERyYWdFdmVudExpc3RlbmVycywgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzfSBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudCc7XG5pbXBvcnQge3BsYWNlQWxsU2hpcERpdnMsIHJlbW92ZUFsbFNoaXBEaXZzfSBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZQbGFjZW1lbnQnO1xuXG5jb25zdCBzZWxmQm9hcmQgPSBHYW1lQm9hcmQoKTtcbmNvbnN0IG9wcG9uZW50Qm9hcmQgPSBHYW1lQm9hcmQoKTtcblxuY29uc3Qgc2VsZkJvYXJkRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlbGYnKTtcbmNvbnN0IG9wcG9uZW50Qm9hcmREaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3Bwb25lbnQnKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIHBsYWNlbWVudCBvZiBzaGlwc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5sZXQge3NoaXBzLCBvcmllbnRhdGlvbnN9ID0gc2hpcFBsYWNlbWVudC5yYW5kb21QbGFjZW1lbnQoc2VsZkJvYXJkKTtcbnBsYWNlQWxsU2hpcERpdnMoc2hpcHMsIG9yaWVudGF0aW9ucyk7XG5cbnNoaXBQbGFjZW1lbnQucmFuZG9tUGxhY2VtZW50KG9wcG9uZW50Qm9hcmQsIG9wcG9uZW50Qm9hcmREaXYpO1xuXG5jb25zb2xlLmxvZyhzZWxmQm9hcmQpO1xuY29uc29sZS5sb2cob3Bwb25lbnRCb2FyZCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIGRpc3BsYXkgYm9hcmRzIGFmdGVyIHNoaXBzIGFyZSBwbGFjZWRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5yZW5kZXJCb2FyZChzZWxmQm9hcmQuYm9hcmRBcnJheSwgc2VsZkJvYXJkRGl2KTtcbnJlbmRlckJvYXJkKG9wcG9uZW50Qm9hcmQuYm9hcmRBcnJheSwgb3Bwb25lbnRCb2FyZERpdik7XG5cbmFkZERyYWdFdmVudExpc3RlbmVycygpO1xuZXhwb3J0IHtvcHBvbmVudEJvYXJkLCBzZWxmQm9hcmQsIHNlbGZCb2FyZERpdn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogaGFuZGxlIGV2ZW50cyBmb3IgcmFuZG9taXplIHBsYWNlbWVudCwgcmVzZXQgZ2FtZSwgc3RhcnQgZ2FtZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCByYW5kb21CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcmFuZG9tQnV0dG9uJyk7XG5yYW5kb21CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2hpcFBsYWNlbWVudC5yZW1vdmVTaGlwcyhzZWxmQm9hcmQpO1xuICAgIHJlbW92ZUFsbFNoaXBEaXZzKCk7XG5cbiAgICBsZXQgcmVzID0gc2hpcFBsYWNlbWVudC5yYW5kb21QbGFjZW1lbnQoc2VsZkJvYXJkKTtcbiAgICBwbGFjZUFsbFNoaXBEaXZzKHJlcy5zaGlwcywgcmVzLm9yaWVudGF0aW9ucyk7XG59KTtcblxuY29uc3Qgc3RhcnRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnRCdXR0b24nKTtcbnN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIG9wcG9uZW50Qm9hcmREaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwbGF5Um91bmQpO1xuICAgIHJlbW92ZURyYWdFdmVudExpc3RlbmVycygpO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")}]);