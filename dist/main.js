!function(n){var i={};function t(o){if(i[o])return i[o].exports;var l=i[o]={i:o,l:!1,exports:{}};return n[o].call(l.exports,l,l.exports,t),l.l=!0,l.exports}t.m=n,t.c=i,t.d=function(n,i,o){t.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,i){if(1&i&&(n=t(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var l in n)t.d(o,l,function(i){return n[i]}.bind(null,l));return o},t.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(i,"a",i),i},t.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},t.p="",t(t.s=2)}([function(module,exports){eval("function Player() {\n    const attack = (board, position) => {\n        board.receiveAttack(position);\n    }\n    return {attack}\n}\n\nmodule.exports = Player;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvUGxheWVyLmpzP2I5NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFBsYXllcigpIHtcbiAgICBjb25zdCBhdHRhY2sgPSAoYm9hcmQsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGJvYXJkLnJlY2VpdmVBdHRhY2socG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge2F0dGFja31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("function Ship(positions) {\n    const positionsHealth = {};\n    positions.forEach(position => positionsHealth[position] = 1);\n\n    const getPositions = () => positionsHealth;\n\n    const hit = (position) => {\n        positionsHealth[position] = 0;\n    }\n    const isSunk = () => {\n        return Object.values(positionsHealth).every(health => health === 0)\n    }\n    return {hit, isSunk, getPositions};\n}\n\nmodule.exports = Ship;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvU2hpcC5qcz9mM2Y5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNoaXAocG9zaXRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb25zSGVhbHRoID0ge307XG4gICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zaXRpb25zSGVhbHRoW3Bvc2l0aW9uXSA9IDEpO1xuXG4gICAgY29uc3QgZ2V0UG9zaXRpb25zID0gKCkgPT4gcG9zaXRpb25zSGVhbHRoO1xuXG4gICAgY29uc3QgaGl0ID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHBvc2l0aW9uc0hlYWx0aFtwb3NpdGlvbl0gPSAwO1xuICAgIH1cbiAgICBjb25zdCBpc1N1bmsgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBvc2l0aW9uc0hlYWx0aCkuZXZlcnkoaGVhbHRoID0+IGhlYWx0aCA9PT0gMClcbiAgICB9XG4gICAgcmV0dXJuIHtoaXQsIGlzU3VuaywgZ2V0UG9zaXRpb25zfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGlwOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"opponentBoard\", function() { return /* binding */ opponentBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoard\", function() { return /* binding */ selfBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoardDiv\", function() { return /* binding */ selfBoardDiv; });\n\n// CONCATENATED MODULE: ./src/modules/Factories/GameBoard.js\nconst Ship = __webpack_require__(1);\n\nfunction GameBoard() {\n    const boardArray = [];\n    let ships = [];\n\n    // Initialize an empty board of size 10 * 10\n    for(let i = 0; i < 100; i ++) {\n        boardArray.push(undefined);\n    }\n\n    const placeShip = (index, positions) => {\n        if(positions.every(position => boardArray[position] === undefined)) {\n            const ship = Ship(positions);\n            positions.forEach(position => boardArray[position] = index);\n            ships.push(ship);\n        } else {\n            console.log(\"one or more positions are occupied\")\n        }\n    }\n\n    const removeAllShips = () => {\n        for(let i = 0; i < 100; i ++) {\n            boardArray[i] = undefined;\n            ships.length = 0;\n        }\n    }\n\n    const updateShip = (index, oldPositions, newPositions) => {\n        // remove ship from old position\n        oldPositions.forEach(position => boardArray[position] = undefined);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // replace old ship with new ship\n        ships[index] = Ship(newPositions);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // place this ship on the boardArray\n        newPositions.forEach(position => boardArray[position] = index);\n    }\n\n    const receiveAttack = (position) => {\n        if(boardArray[position] === undefined) {\n            boardArray[position] = 'miss';\n        } else if (boardArray[position] !== 'miss' && boardArray[position] !== 'hit'){\n            const index = boardArray[position];\n            const hitShip = ships[index];\n            hitShip.hit(position);\n            boardArray[position] = 'hit';\n        }\n    }\n\n    const allShipsSunk = () => {\n        return ships.every(ship => ship.isSunk());\n    }\n\n    return {\n        boardArray,\n        ships,\n        placeShip,\n        removeAllShips,\n        updateShip,\n        receiveAttack,\n        allShipsSunk\n    }\n}\n\n/* harmony default export */ var Factories_GameBoard = (GameBoard);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/BoardDisplay.js\nfunction renderBoard(boardArray, boardDiv) {\n\n    boardArray.forEach( (value, index = 0) => {\n        const cell = document.createElement('div');\n        cell.classList.add('cell');\n        cell.setAttribute('data-key', index);\n        boardDiv.appendChild(cell);\n    })\n}\n\n/* harmony default export */ var BoardDisplay = (renderBoard);\n// EXTERNAL MODULE: ./src/modules/Factories/Player.js\nvar Player = __webpack_require__(0);\nvar Player_default = /*#__PURE__*/__webpack_require__.n(Player);\n\n// CONCATENATED MODULE: ./src/modules/ComputerAttack.js\n\n\nfunction validatePosition(direction, hit, position) {\n    // check if the position is on the board\n    if(position < 0 || position > 99) return undefined;\n\n    // check if on the same row, because rows are wrapped\n    if(direction === 'left' || direction === 'right') {\n        const hitRow = Math.floor(hit / 10);\n        const positionRow = Math.floor(position / 10);\n        if(hitRow !== positionRow) return undefined;\n    }\n\n    // check if position had already been attacked\n    let nextPosition = position\n    let cellValue = selfBoard.boardArray[nextPosition];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        nextPosition = getPositionBasedOnHit(position, direction);\n        cellValue = selfBoard.boardArray[nextPosition];\n    }\n    return nextPosition;\n}\n\nfunction getPositionBasedOnHit(hit, direction) {\n    let position;\n    switch (direction) {\n        case 'up':\n            position = hit - 10;\n            break;\n\n        case 'down':\n            position = hit + 10;\n            break;\n\n        case 'left':\n            position = hit - 1;\n            break;\n\n        case 'right':\n            position = hit + 1;\n    }\n    return validatePosition(direction, hit, position);\n}\n\nfunction getRandomPosition() {\n    let position = Math.floor(Math.random() * 100);\n    let cellValue = selfBoard.boardArray[position];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        position = Math.floor(Math.random() * 100);\n        cellValue = selfBoard.boardArray[position];\n    }\n    return position;\n}\n\nfunction ComputerAttack() {\n    let hit;\n    let directions = ['up', 'down', 'left', 'right'];\n\n    const updateHits = (position) => {\n        hit = position;\n    }\n\n    const updateMiss = () => {\n        if(!hit) return;\n        directions.shift();\n\n        // If we've checked in all directions, setup variables for next hit\n        if(directions.length === 0) {\n            hit = undefined;\n            directions = ['up', 'down', 'left', 'right'];\n        }\n    }\n\n    const getComputerAttackPosition = () => {\n        if(hit) {\n            console.log('inside ' + hit + directions);\n\n            // get a valid position i.e on board and on same column for vertical ships\n            let position =  getPositionBasedOnHit(hit, directions[0]);\n            while (!position) {\n                directions.shift();\n                if(directions.length === 0) {\n                    hit = undefined;\n                    directions = ['up', 'down', 'left', 'right'];\n                    return getRandomPosition();\n                }\n                position = getPositionBasedOnHit(hit, directions[0]);\n            }\n            return position;\n        }\n        return getRandomPosition();\n    }\n\n    return {getComputerAttackPosition, updateMiss, updateHits};\n}\n\n/* harmony default export */ var modules_ComputerAttack = (ComputerAttack);\n// CONCATENATED MODULE: ./src/modules/GameLoop.js\n\n\n\n\nconst human = Player_default()();\nconst computer = Player_default()();\nconst computerAttack = modules_ComputerAttack();\n\nfunction playRound(e) {\n    if(selfBoard.allShipsSunk() || opponentBoard.allShipsSunk()) {\n        const winner = opponentBoard.allShipsSunk() ? 'human' : 'computer';\n        console.log(`winner is ${winner}`);\n        return;\n    }\n    // human's attack on computer\n    let cell = e.target;\n    let position = cell.getAttribute('data-key');\n\n    // Don't play round if user attacks already attacked position\n    if([...cell.classList].includes('hit') || [...cell.classList].includes('miss')) return;\n\n    attack(human, opponentBoard, cell, position);\n\n    // computer's attack on human\n    position = computerAttack.getComputerAttackPosition();\n    console.log(position);\n    cell = selfBoardDiv.querySelector(`div[data-key=\"${position}\"]`);\n\n    const computerResult = attack(computer, selfBoard, cell, position);\n    console.log(computerResult);\n\n    // Update hits and misses so computer can make intelligent guesses next time\n    if(computerResult === 'hit') {\n        computerAttack.updateHits(position);\n    } else {\n        computerAttack.updateMiss(position);\n    }\n}\n\nfunction attack(player, board, cell, position){\n    player.attack(board, position);\n    const result = board.boardArray[position];\n    if (result === 'miss') {\n        cell.classList.add('miss');\n    } else if (result === 'hit'){\n        cell.classList.add('hit');\n    }\n    return result;\n}\n\n/* harmony default export */ var GameLoop = (playRound);\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipPlacement.js\nfunction checkValidHorizontalPosition(unaivalablePositions, position, size) {\n    const row = Math.floor(position / 10);\n    const end = (row + 1) * 10;\n\n    // checking if last position will be in the same row\n    if(position + size - 1 >= end) {\n        return false\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position ++;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction checkValidVerticalPosition(unaivalablePositions, position, size) {\n    const col = position % 10;\n    const end = col + 90;\n\n    // checking if last position will be in the same column\n    if(position + (size - 1) * 10 > end) {\n        return false;\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position += 10;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction isvalidPosition(unaivalablePositions ,position, size, orientation) {\n    if(unaivalablePositions.includes(position)) return false;\n\n    if(orientation === 'horizontal') {\n        return checkValidHorizontalPosition(unaivalablePositions, position, size);\n    } else {\n        return checkValidVerticalPosition(unaivalablePositions, position, size);\n    }\n}\n\nfunction getValidPosition(unavailablePositions, size, orientation) {\n    let position = Math.floor(Math.random() * 100);\n    while(!isvalidPosition(unavailablePositions, position, size, orientation))\n    {\n        position = Math.floor(Math.random() * 100);\n    }\n    return position;\n}\n\nfunction makeShips() {\n    const unavailablePositions = [];\n    const ships = [];\n    const orientations = [];\n    // let's make 5 ships of sizes 1 to 5\n    for(let size = 1; size <= 5; size ++) {\n        let orientation = size % 2 ? 'vertical' : 'horizontal';\n        orientations.push(orientation);\n\n        let ship = [];\n        let position = getValidPosition(unavailablePositions, size, orientation);\n        for(let i = 0; i < size; i ++) {\n            ship.push(position);\n            unavailablePositions.push(position);\n            if(orientation === 'vertical') {\n                position += 10;\n            } else {\n                position ++;\n            }\n        }\n        ships.push(ship);\n    }\n    console.log(ships, orientations);\n    return {ships, orientations};\n}\n\nconst shipPlacement = {\n    randomPlacement(board) {\n        const {ships, orientations} = makeShips();\n        ships.forEach((ship, index= 0 )=> {\n            board.placeShip(index, ship);\n        });\n        return {ships, orientations};\n    },\n    removeShips(board) {\n        board.removeAllShips();\n    }\n}\n\n/* harmony default export */ var ShipPlacement = (shipPlacement);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivPlacement.js\n\n\nfunction styleShip(ship, orientation, start, end) {\n    if(orientation === 'vertical') {\n        ship.setAttribute('data-top', start);\n        ship.setAttribute('data-bottom', end);\n    } else {\n        ship.setAttribute('data-left', start);\n        ship.setAttribute('data-right', end);\n    }\n    const topOffset = Math.floor(start/ 10);\n    const leftOffset = start % 10;\n\n    ship.style.top = `${topOffset * 42}px`;\n    ship.style.left = `${leftOffset * 42}px`;\n}\n\nfunction makeShipDiv(orientation, shipNum, length) {\n    const div = document.createElement('div');\n    div.classList.add('ship');\n    div.draggable = true;\n    div.classList.add(orientation);\n    div.setAttribute('data-ship', shipNum);\n    div.setAttribute('data-length', length);\n    if(orientation === 'vertical') {\n        div.style.width = '40px';\n        div.style.height = `${40 * length}px`;\n    } else {\n        div.style.height = '40px';\n        div.style.width = `${40 * length}px`;\n    }\n    return div;\n}\n\nfunction placeShipDivs(container, shipNum, orientation, length, start, end) {\n    const ship = makeShipDiv(orientation, shipNum, length);\n    styleShip(ship, orientation, start, end);\n    container.appendChild(ship);\n}\n\nfunction placeAllShipDivs(ships, orientations) {\n    ships.forEach((ship, index= 0 )=> {\n        const length = ship.length;\n        const start = ship[0];\n        const end = ship[length - 1];\n        placeShipDivs(selfBoardDiv, `${index}`, orientations[index], length, start, end);\n    });\n}\n\nfunction removeAllShipDivs() {\n    const shipDivs = document.querySelectorAll('.ship');\n    shipDivs.forEach(shipDiv => selfBoardDiv.removeChild(shipDiv));\n}\n\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovementHandler.js\n\n\n\nfunction moveShipDiv(ship, cell, orientation, length) {\n    if(orientation === 'vertical') {\n        const newBottom = cell.getAttribute('data-key');\n        const newTop = newBottom - (length - 1) * 10;\n        if(newTop < 0) return;\n\n        styleShip(ship, 'vertical', newTop, newBottom);\n    } else {\n        const newRight = cell.getAttribute('data-key');\n        const row = Math.floor(newRight / 10);\n        const newLeft = newRight - (length - 1);\n        if(newLeft < row * 10) return;\n\n        styleShip(ship, 'horizontal', newLeft, newRight);\n    }\n}\n\nfunction getPositionsFromShipDiv(orientation, length, end) {\n    const positions = [];\n    let position = end;\n\n    const decrement = orientation === 'vertical' ? 10 : 1;\n\n    for(let i = 0; i < length; i ++) {\n        positions.push(position);\n        position -= decrement;\n    }\n    return positions;\n}\n\nfunction areValidPositions(newPositions, oldPositions) {\n    return newPositions.every(newPosition => {\n        // each position must either be empty or one of previous positions\n        return (selfBoard.boardArray[newPosition] === undefined\n                || oldPositions.includes(newPosition)\n        )\n    });\n}\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovement.js\n\n\n\n// draggable event listeners\nfunction shipDivListeners() {\n    const shipDivs = selfBoardDiv.querySelectorAll('.ship');\n    shipDivs.forEach(ship => ship.addEventListener('dragstart', dragStart));\n    shipDivs.forEach(ship => ship.addEventListener('dragend', dragEnd));\n}\n\n// cell event listeners\nfunction cellListeners() {\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    cells.forEach(cell => cell.addEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.addEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.addEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.addEventListener('drop', dragDrop));\n}\n\nfunction addDragEventListeners() {\n    shipDivListeners();\n    cellListeners();\n}\n\nfunction removeDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.removeEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.removeEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.removeEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.removeEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.removeEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.removeEventListener('drop', dragDrop));\n}\n\n// Dragging functions\n\nfunction dragStart(e) {\n    console.log('start');\n    const shipNum = this.getAttribute('data-ship');\n    e.dataTransfer.setData(\"text\", shipNum);\n    setTimeout(() => this.classList.add('hidden'), 0);\n}\n\nfunction dragEnd() {\n    console.log('end');\n    this.classList.remove('hidden');\n}\n\nfunction dragOver(e) {\n    console.log('over');\n    e.preventDefault();\n}\n\nfunction dragEnter() {\n    console.log('enter');\n    this.classList.add('hovered');\n}\n\nfunction dragLeave() {\n    console.log('leave');\n    this.className = 'cell';\n}\n\nfunction dragDrop(e) {\n    console.log('drop');\n    e.preventDefault();\n    const data = e.dataTransfer.getData(\"text\");\n    console.log(data);\n    this.className = 'cell';\n    const ship = selfBoardDiv.querySelector(`.ship[data-ship='${data}']`);\n    const cell = this;\n    console.log(ship, cell);\n    handleDrop(ship, cell);\n}\n\nfunction handleDrop(ship, cell) {\n    // move the div\n    const orientation = [...ship.classList].includes('horizontal') ? 'horizontal' : 'vertical';\n    const length = ship.getAttribute('data-length');\n\n    // get old end and positions\n    const oldEnd = orientation === 'horizontal' ?\n        parseInt(ship.getAttribute('data-right'))\n        : parseInt(ship.getAttribute('data-bottom'));\n    const oldPositions = getPositionsFromShipDiv(orientation, length, oldEnd);\n    console.log(oldEnd, oldPositions);\n\n    // check if moving this div will cause any of the positions to overlap\n    const newEnd = parseInt(cell.getAttribute('data-key'));\n    const newPositions = getPositionsFromShipDiv(orientation, length, newEnd);\n\n    if(!areValidPositions(newPositions, oldPositions)) return;\n    console.log(newEnd, newPositions);\n\n    moveShipDiv(ship, cell, orientation, length);\n\n    const shipIndex = parseInt(ship.getAttribute('data-ship'));\n    console.log(shipIndex, oldPositions, newPositions);\n    selfBoard.updateShip(shipIndex, oldPositions, newPositions);\n}\n\n\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\nconst selfBoard = Factories_GameBoard();\nconst opponentBoard = Factories_GameBoard();\n\nconst selfBoardDiv = document.querySelector('#self');\nconst opponentBoardDiv = document.querySelector('#opponent');\n/******************************************************************************************\n * placement of ships\n *******************************************************************************************/\nlet {ships: src_ships, orientations: src_orientations} = ShipPlacement.randomPlacement(selfBoard);\nplaceAllShipDivs(src_ships, src_orientations);\n\nShipPlacement.randomPlacement(opponentBoard, opponentBoardDiv);\n\nconsole.log(selfBoard);\nconsole.log(opponentBoard);\n\n/******************************************************************************************\n * display boards after ships are placed\n *******************************************************************************************/\n\nBoardDisplay(selfBoard.boardArray, selfBoardDiv);\nBoardDisplay(opponentBoard.boardArray, opponentBoardDiv);\n\naddDragEventListeners();\n\n\n/******************************************************************************************\n * handle events for randomize placement, reset game, start game\n *******************************************************************************************/\nconst gameControls = document.querySelector('#gameControls');\n\nconst randomButton = document.querySelector('#randomButton');\nrandomButton.addEventListener('click', () => {\n    ShipPlacement.removeShips(selfBoard);\n    removeAllShipDivs();\n\n    console.log(selfBoard.boardArray, selfBoard.ships);\n    let res = ShipPlacement.randomPlacement(selfBoard);\n    placeAllShipDivs(res.ships, res.orientations);\n    shipDivListeners();\n    console.log(selfBoard.boardArray, selfBoard.ships);\n\n});\n\nconst startButton = document.querySelector('#startButton');\nstartButton.addEventListener('click', () => {\n    opponentBoardDiv.addEventListener('click', GameLoop);\n    removeDragEventListeners();\n    gameControls.classList.add('hidden');\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkLmpzPzkyY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheS5qcz8yYzIyIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0NvbXB1dGVyQXR0YWNrLmpzPzY2NmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvR2FtZUxvb3AuanM/M2Y4YSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudC5qcz9mNzQ1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50LmpzPzE2YTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudEhhbmRsZXIuanM/Y2UyMSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcERpdk1vdmVtZW50LmpzP2UyMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsYUFBYSxtQkFBTyxDQUFDLENBQVE7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRTJFOzs7QUN6R3JCO0FBQ1c7QUFDdEI7QUFDeUI7QUFLakI7QUFDNEM7O0FBRS9GLGtCQUFrQixtQkFBUztBQUMzQixzQkFBc0IsbUJBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUsseUJBQWMsbUJBQUMsR0FBRyxhQUFhO0FBQ3pDLGdCQUFnQixDQUFDLFNBQUssRUFBRSxnQkFBWTs7QUFFcEMsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1gsWUFBVzs7QUFFWCxxQkFBcUI7QUFDMEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakIsSUFBSSxpQkFBaUI7O0FBRXJCO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksZ0JBQWdCO0FBQ3BCOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtDQUErQyxRQUFTO0FBQ3hELElBQUksd0JBQXdCO0FBQzVCO0FBQ0EsQ0FBQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2hpcCA9IHJlcXVpcmUoJy4vU2hpcCcpO1xuXG5mdW5jdGlvbiBHYW1lQm9hcmQoKSB7XG4gICAgY29uc3QgYm9hcmRBcnJheSA9IFtdO1xuICAgIGxldCBzaGlwcyA9IFtdO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBhbiBlbXB0eSBib2FyZCBvZiBzaXplIDEwICogMTBcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTAwOyBpICsrKSB7XG4gICAgICAgIGJvYXJkQXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYWNlU2hpcCA9IChpbmRleCwgcG9zaXRpb25zKSA9PiB7XG4gICAgICAgIGlmKHBvc2l0aW9ucy5ldmVyeShwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgY29uc3Qgc2hpcCA9IFNoaXAocG9zaXRpb25zKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IGJvYXJkQXJyYXlbcG9zaXRpb25dID0gaW5kZXgpO1xuICAgICAgICAgICAgc2hpcHMucHVzaChzaGlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25lIG9yIG1vcmUgcG9zaXRpb25zIGFyZSBvY2N1cGllZFwiKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlQWxsU2hpcHMgPSAoKSA9PiB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMDA7IGkgKyspIHtcbiAgICAgICAgICAgIGJvYXJkQXJyYXlbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzaGlwcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlU2hpcCA9IChpbmRleCwgb2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpID0+IHtcbiAgICAgICAgLy8gcmVtb3ZlIHNoaXAgZnJvbSBvbGQgcG9zaXRpb25cbiAgICAgICAgb2xkUG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gYm9hcmRBcnJheVtwb3NpdGlvbl0gPSB1bmRlZmluZWQpO1xuXG4gICAgICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBjb25zb2xlLmxvZyhzaGlwLmdldFBvc2l0aW9ucygpKSk7XG4gICAgICAgIC8vIHJlcGxhY2Ugb2xkIHNoaXAgd2l0aCBuZXcgc2hpcFxuICAgICAgICBzaGlwc1tpbmRleF0gPSBTaGlwKG5ld1Bvc2l0aW9ucyk7XG5cbiAgICAgICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IGNvbnNvbGUubG9nKHNoaXAuZ2V0UG9zaXRpb25zKCkpKTtcbiAgICAgICAgLy8gcGxhY2UgdGhpcyBzaGlwIG9uIHRoZSBib2FyZEFycmF5XG4gICAgICAgIG5ld1Bvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IGJvYXJkQXJyYXlbcG9zaXRpb25dID0gaW5kZXgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY2VpdmVBdHRhY2sgPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgaWYoYm9hcmRBcnJheVtwb3NpdGlvbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm9hcmRBcnJheVtwb3NpdGlvbl0gPSAnbWlzcyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYm9hcmRBcnJheVtwb3NpdGlvbl0gIT09ICdtaXNzJyAmJiBib2FyZEFycmF5W3Bvc2l0aW9uXSAhPT0gJ2hpdCcpe1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBib2FyZEFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGNvbnN0IGhpdFNoaXAgPSBzaGlwc1tpbmRleF07XG4gICAgICAgICAgICBoaXRTaGlwLmhpdChwb3NpdGlvbik7XG4gICAgICAgICAgICBib2FyZEFycmF5W3Bvc2l0aW9uXSA9ICdoaXQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWxsU2hpcHNTdW5rID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gc2hpcHMuZXZlcnkoc2hpcCA9PiBzaGlwLmlzU3VuaygpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBib2FyZEFycmF5LFxuICAgICAgICBzaGlwcyxcbiAgICAgICAgcGxhY2VTaGlwLFxuICAgICAgICByZW1vdmVBbGxTaGlwcyxcbiAgICAgICAgdXBkYXRlU2hpcCxcbiAgICAgICAgcmVjZWl2ZUF0dGFjayxcbiAgICAgICAgYWxsU2hpcHNTdW5rXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHYW1lQm9hcmQ7XG4iLCJmdW5jdGlvbiByZW5kZXJCb2FyZChib2FyZEFycmF5LCBib2FyZERpdikge1xuXG4gICAgYm9hcmRBcnJheS5mb3JFYWNoKCAodmFsdWUsIGluZGV4ID0gMCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnY2VsbCcpO1xuICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZSgnZGF0YS1rZXknLCBpbmRleCk7XG4gICAgICAgIGJvYXJkRGl2LmFwcGVuZENoaWxkKGNlbGwpO1xuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlckJvYXJkOyIsImltcG9ydCB7c2VsZkJvYXJkfSBmcm9tICcuLi9pbmRleCc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpb24oZGlyZWN0aW9uLCBoaXQsIHBvc2l0aW9uKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHBvc2l0aW9uIGlzIG9uIHRoZSBib2FyZFxuICAgIGlmKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IDk5KSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gY2hlY2sgaWYgb24gdGhlIHNhbWUgcm93LCBiZWNhdXNlIHJvd3MgYXJlIHdyYXBwZWRcbiAgICBpZihkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgY29uc3QgaGl0Um93ID0gTWF0aC5mbG9vcihoaXQgLyAxMCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUm93ID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIDEwKTtcbiAgICAgICAgaWYoaGl0Um93ICE9PSBwb3NpdGlvblJvdykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBwb3NpdGlvbiBoYWQgYWxyZWFkeSBiZWVuIGF0dGFja2VkXG4gICAgbGV0IG5leHRQb3NpdGlvbiA9IHBvc2l0aW9uXG4gICAgbGV0IGNlbGxWYWx1ZSA9IHNlbGZCb2FyZC5ib2FyZEFycmF5W25leHRQb3NpdGlvbl07XG4gICAgd2hpbGUoY2VsbFZhbHVlID09PSAnbWlzcycgfHwgY2VsbFZhbHVlID09PSAnaGl0Jykge1xuICAgICAgICBuZXh0UG9zaXRpb24gPSBnZXRQb3NpdGlvbkJhc2VkT25IaXQocG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICAgIGNlbGxWYWx1ZSA9IHNlbGZCb2FyZC5ib2FyZEFycmF5W25leHRQb3NpdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBuZXh0UG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uQmFzZWRPbkhpdChoaXQsIGRpcmVjdGlvbikge1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGhpdCAtIDEwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGhpdCArIDEwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGhpdCAtIDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGhpdCArIDE7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVBvc2l0aW9uKGRpcmVjdGlvbiwgaGl0LCBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbVBvc2l0aW9uKCkge1xuICAgIGxldCBwb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgbGV0IGNlbGxWYWx1ZSA9IHNlbGZCb2FyZC5ib2FyZEFycmF5W3Bvc2l0aW9uXTtcbiAgICB3aGlsZShjZWxsVmFsdWUgPT09ICdtaXNzJyB8fCBjZWxsVmFsdWUgPT09ICdoaXQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICAgICAgY2VsbFZhbHVlID0gc2VsZkJvYXJkLmJvYXJkQXJyYXlbcG9zaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIENvbXB1dGVyQXR0YWNrKCkge1xuICAgIGxldCBoaXQ7XG4gICAgbGV0IGRpcmVjdGlvbnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCddO1xuXG4gICAgY29uc3QgdXBkYXRlSGl0cyA9IChwb3NpdGlvbikgPT4ge1xuICAgICAgICBoaXQgPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVNaXNzID0gKCkgPT4ge1xuICAgICAgICBpZighaGl0KSByZXR1cm47XG4gICAgICAgIGRpcmVjdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICAvLyBJZiB3ZSd2ZSBjaGVja2VkIGluIGFsbCBkaXJlY3Rpb25zLCBzZXR1cCB2YXJpYWJsZXMgZm9yIG5leHQgaGl0XG4gICAgICAgIGlmKGRpcmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBoaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkaXJlY3Rpb25zID0gWyd1cCcsICdkb3duJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdldENvbXB1dGVyQXR0YWNrUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGlmKGhpdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2luc2lkZSAnICsgaGl0ICsgZGlyZWN0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGdldCBhIHZhbGlkIHBvc2l0aW9uIGkuZSBvbiBib2FyZCBhbmQgb24gc2FtZSBjb2x1bW4gZm9yIHZlcnRpY2FsIHNoaXBzXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAgZ2V0UG9zaXRpb25CYXNlZE9uSGl0KGhpdCwgZGlyZWN0aW9uc1swXSk7XG4gICAgICAgICAgICB3aGlsZSAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9ucyA9IFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYW5kb21Qb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGdldFBvc2l0aW9uQmFzZWRPbkhpdChoaXQsIGRpcmVjdGlvbnNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRSYW5kb21Qb3NpdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB7Z2V0Q29tcHV0ZXJBdHRhY2tQb3NpdGlvbiwgdXBkYXRlTWlzcywgdXBkYXRlSGl0c307XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbXB1dGVyQXR0YWNrOyIsImltcG9ydCBQbGF5ZXIgZnJvbSAnLi9GYWN0b3JpZXMvUGxheWVyJztcbmltcG9ydCB7c2VsZkJvYXJkLCBvcHBvbmVudEJvYXJkLCBzZWxmQm9hcmREaXZ9IGZyb20gJy4uL2luZGV4JztcbmltcG9ydCBDb21wdXRlckF0dGFjayBmcm9tICcuL0NvbXB1dGVyQXR0YWNrJztcblxuY29uc3QgaHVtYW4gPSBQbGF5ZXIoKTtcbmNvbnN0IGNvbXB1dGVyID0gUGxheWVyKCk7XG5jb25zdCBjb21wdXRlckF0dGFjayA9IENvbXB1dGVyQXR0YWNrKCk7XG5cbmZ1bmN0aW9uIHBsYXlSb3VuZChlKSB7XG4gICAgaWYoc2VsZkJvYXJkLmFsbFNoaXBzU3VuaygpIHx8IG9wcG9uZW50Qm9hcmQuYWxsU2hpcHNTdW5rKCkpIHtcbiAgICAgICAgY29uc3Qgd2lubmVyID0gb3Bwb25lbnRCb2FyZC5hbGxTaGlwc1N1bmsoKSA/ICdodW1hbicgOiAnY29tcHV0ZXInO1xuICAgICAgICBjb25zb2xlLmxvZyhgd2lubmVyIGlzICR7d2lubmVyfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGh1bWFuJ3MgYXR0YWNrIG9uIGNvbXB1dGVyXG4gICAgbGV0IGNlbGwgPSBlLnRhcmdldDtcbiAgICBsZXQgcG9zaXRpb24gPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKTtcblxuICAgIC8vIERvbid0IHBsYXkgcm91bmQgaWYgdXNlciBhdHRhY2tzIGFscmVhZHkgYXR0YWNrZWQgcG9zaXRpb25cbiAgICBpZihbLi4uY2VsbC5jbGFzc0xpc3RdLmluY2x1ZGVzKCdoaXQnKSB8fCBbLi4uY2VsbC5jbGFzc0xpc3RdLmluY2x1ZGVzKCdtaXNzJykpIHJldHVybjtcblxuICAgIGF0dGFjayhodW1hbiwgb3Bwb25lbnRCb2FyZCwgY2VsbCwgcG9zaXRpb24pO1xuXG4gICAgLy8gY29tcHV0ZXIncyBhdHRhY2sgb24gaHVtYW5cbiAgICBwb3NpdGlvbiA9IGNvbXB1dGVyQXR0YWNrLmdldENvbXB1dGVyQXR0YWNrUG9zaXRpb24oKTtcbiAgICBjb25zb2xlLmxvZyhwb3NpdGlvbik7XG4gICAgY2VsbCA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yKGBkaXZbZGF0YS1rZXk9XCIke3Bvc2l0aW9ufVwiXWApO1xuXG4gICAgY29uc3QgY29tcHV0ZXJSZXN1bHQgPSBhdHRhY2soY29tcHV0ZXIsIHNlbGZCb2FyZCwgY2VsbCwgcG9zaXRpb24pO1xuICAgIGNvbnNvbGUubG9nKGNvbXB1dGVyUmVzdWx0KTtcblxuICAgIC8vIFVwZGF0ZSBoaXRzIGFuZCBtaXNzZXMgc28gY29tcHV0ZXIgY2FuIG1ha2UgaW50ZWxsaWdlbnQgZ3Vlc3NlcyBuZXh0IHRpbWVcbiAgICBpZihjb21wdXRlclJlc3VsdCA9PT0gJ2hpdCcpIHtcbiAgICAgICAgY29tcHV0ZXJBdHRhY2sudXBkYXRlSGl0cyhwb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcHV0ZXJBdHRhY2sudXBkYXRlTWlzcyhwb3NpdGlvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2socGxheWVyLCBib2FyZCwgY2VsbCwgcG9zaXRpb24pe1xuICAgIHBsYXllci5hdHRhY2soYm9hcmQsIHBvc2l0aW9uKTtcbiAgICBjb25zdCByZXN1bHQgPSBib2FyZC5ib2FyZEFycmF5W3Bvc2l0aW9uXTtcbiAgICBpZiAocmVzdWx0ID09PSAnbWlzcycpIHtcbiAgICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKCdtaXNzJyk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgPT09ICdoaXQnKXtcbiAgICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKCdoaXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGxheVJvdW5kOyIsImZ1bmN0aW9uIGNoZWNrVmFsaWRIb3Jpem9udGFsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIDEwKTtcbiAgICBjb25zdCBlbmQgPSAocm93ICsgMSkgKiAxMDtcblxuICAgIC8vIGNoZWNraW5nIGlmIGxhc3QgcG9zaXRpb24gd2lsbCBiZSBpbiB0aGUgc2FtZSByb3dcbiAgICBpZihwb3NpdGlvbiArIHNpemUgLSAxID49IGVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgcG9zaXRpb25zIHdpdGggdGhpcyBzdGFydGluZyBwb3NpdGlvbiBhcmUgYXZhaWxhYmxlXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKyspIHtcbiAgICAgICAgcG9zaXRpb24gKys7XG4gICAgICAgIGlmKHVuYWl2YWxhYmxlUG9zaXRpb25zLmluY2x1ZGVzKHBvc2l0aW9uKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja1ZhbGlkVmVydGljYWxQb3NpdGlvbih1bmFpdmFsYWJsZVBvc2l0aW9ucywgcG9zaXRpb24sIHNpemUpIHtcbiAgICBjb25zdCBjb2wgPSBwb3NpdGlvbiAlIDEwO1xuICAgIGNvbnN0IGVuZCA9IGNvbCArIDkwO1xuXG4gICAgLy8gY2hlY2tpbmcgaWYgbGFzdCBwb3NpdGlvbiB3aWxsIGJlIGluIHRoZSBzYW1lIGNvbHVtblxuICAgIGlmKHBvc2l0aW9uICsgKHNpemUgLSAxKSAqIDEwID4gZW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgcG9zaXRpb25zIHdpdGggdGhpcyBzdGFydGluZyBwb3NpdGlvbiBhcmUgYXZhaWxhYmxlXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKyspIHtcbiAgICAgICAgcG9zaXRpb24gKz0gMTA7XG4gICAgICAgIGlmKHVuYWl2YWxhYmxlUG9zaXRpb25zLmluY2x1ZGVzKHBvc2l0aW9uKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc3ZhbGlkUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMgLHBvc2l0aW9uLCBzaXplLCBvcmllbnRhdGlvbikge1xuICAgIGlmKHVuYWl2YWxhYmxlUG9zaXRpb25zLmluY2x1ZGVzKHBvc2l0aW9uKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICByZXR1cm4gY2hlY2tWYWxpZEhvcml6b250YWxQb3NpdGlvbih1bmFpdmFsYWJsZVBvc2l0aW9ucywgcG9zaXRpb24sIHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja1ZhbGlkVmVydGljYWxQb3NpdGlvbih1bmFpdmFsYWJsZVBvc2l0aW9ucywgcG9zaXRpb24sIHNpemUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWRQb3NpdGlvbih1bmF2YWlsYWJsZVBvc2l0aW9ucywgc2l6ZSwgb3JpZW50YXRpb24pIHtcbiAgICBsZXQgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIHdoaWxlKCFpc3ZhbGlkUG9zaXRpb24odW5hdmFpbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplLCBvcmllbnRhdGlvbikpXG4gICAge1xuICAgICAgICBwb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gbWFrZVNoaXBzKCkge1xuICAgIGNvbnN0IHVuYXZhaWxhYmxlUG9zaXRpb25zID0gW107XG4gICAgY29uc3Qgc2hpcHMgPSBbXTtcbiAgICBjb25zdCBvcmllbnRhdGlvbnMgPSBbXTtcbiAgICAvLyBsZXQncyBtYWtlIDUgc2hpcHMgb2Ygc2l6ZXMgMSB0byA1XG4gICAgZm9yKGxldCBzaXplID0gMTsgc2l6ZSA8PSA1OyBzaXplICsrKSB7XG4gICAgICAgIGxldCBvcmllbnRhdGlvbiA9IHNpemUgJSAyID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgICAgb3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pO1xuXG4gICAgICAgIGxldCBzaGlwID0gW107XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGdldFZhbGlkUG9zaXRpb24odW5hdmFpbGFibGVQb3NpdGlvbnMsIHNpemUsIG9yaWVudGF0aW9uKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKyspIHtcbiAgICAgICAgICAgIHNoaXAucHVzaChwb3NpdGlvbik7XG4gICAgICAgICAgICB1bmF2YWlsYWJsZVBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMTA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoaXBzLnB1c2goc2hpcCk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKHNoaXBzLCBvcmllbnRhdGlvbnMpO1xuICAgIHJldHVybiB7c2hpcHMsIG9yaWVudGF0aW9uc307XG59XG5cbmNvbnN0IHNoaXBQbGFjZW1lbnQgPSB7XG4gICAgcmFuZG9tUGxhY2VtZW50KGJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHtzaGlwcywgb3JpZW50YXRpb25zfSA9IG1ha2VTaGlwcygpO1xuICAgICAgICBzaGlwcy5mb3JFYWNoKChzaGlwLCBpbmRleD0gMCApPT4ge1xuICAgICAgICAgICAgYm9hcmQucGxhY2VTaGlwKGluZGV4LCBzaGlwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7c2hpcHMsIG9yaWVudGF0aW9uc307XG4gICAgfSxcbiAgICByZW1vdmVTaGlwcyhib2FyZCkge1xuICAgICAgICBib2FyZC5yZW1vdmVBbGxTaGlwcygpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hpcFBsYWNlbWVudDtcbiIsImltcG9ydCB7c2VsZkJvYXJkRGl2fSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcblxuZnVuY3Rpb24gc3R5bGVTaGlwKHNoaXAsIG9yaWVudGF0aW9uLCBzdGFydCwgZW5kKSB7XG4gICAgaWYob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgc2hpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdG9wJywgc3RhcnQpO1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1ib3R0b20nLCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoaXAuc2V0QXR0cmlidXRlKCdkYXRhLWxlZnQnLCBzdGFydCk7XG4gICAgICAgIHNoaXAuc2V0QXR0cmlidXRlKCdkYXRhLXJpZ2h0JywgZW5kKTtcbiAgICB9XG4gICAgY29uc3QgdG9wT2Zmc2V0ID0gTWF0aC5mbG9vcihzdGFydC8gMTApO1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBzdGFydCAlIDEwO1xuXG4gICAgc2hpcC5zdHlsZS50b3AgPSBgJHt0b3BPZmZzZXQgKiA0Mn1weGA7XG4gICAgc2hpcC5zdHlsZS5sZWZ0ID0gYCR7bGVmdE9mZnNldCAqIDQyfXB4YDtcbn1cblxuZnVuY3Rpb24gbWFrZVNoaXBEaXYob3JpZW50YXRpb24sIHNoaXBOdW0sIGxlbmd0aCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdzaGlwJyk7XG4gICAgZGl2LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQob3JpZW50YXRpb24pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2hpcCcsIHNoaXBOdW0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGVuZ3RoJywgbGVuZ3RoKTtcbiAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAnNDBweCc7XG4gICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHs0MCAqIGxlbmd0aH1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICc0MHB4JztcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gYCR7NDAgKiBsZW5ndGh9cHhgO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xufVxuXG5mdW5jdGlvbiBwbGFjZVNoaXBEaXZzKGNvbnRhaW5lciwgc2hpcE51bSwgb3JpZW50YXRpb24sIGxlbmd0aCwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHNoaXAgPSBtYWtlU2hpcERpdihvcmllbnRhdGlvbiwgc2hpcE51bSwgbGVuZ3RoKTtcbiAgICBzdHlsZVNoaXAoc2hpcCwgb3JpZW50YXRpb24sIHN0YXJ0LCBlbmQpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzaGlwKTtcbn1cblxuZnVuY3Rpb24gcGxhY2VBbGxTaGlwRGl2cyhzaGlwcywgb3JpZW50YXRpb25zKSB7XG4gICAgc2hpcHMuZm9yRWFjaCgoc2hpcCwgaW5kZXg9IDAgKT0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2hpcC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc2hpcFswXTtcbiAgICAgICAgY29uc3QgZW5kID0gc2hpcFtsZW5ndGggLSAxXTtcbiAgICAgICAgcGxhY2VTaGlwRGl2cyhzZWxmQm9hcmREaXYsIGAke2luZGV4fWAsIG9yaWVudGF0aW9uc1tpbmRleF0sIGxlbmd0aCwgc3RhcnQsIGVuZCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbFNoaXBEaXZzKCkge1xuICAgIGNvbnN0IHNoaXBEaXZzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNoaXAnKTtcbiAgICBzaGlwRGl2cy5mb3JFYWNoKHNoaXBEaXYgPT4gc2VsZkJvYXJkRGl2LnJlbW92ZUNoaWxkKHNoaXBEaXYpKTtcbn1cblxuZXhwb3J0IHtzdHlsZVNoaXAsIHBsYWNlQWxsU2hpcERpdnMsIHJlbW92ZUFsbFNoaXBEaXZzfTtcbiIsImltcG9ydCB7c3R5bGVTaGlwfSBmcm9tICcuL1NoaXBEaXZQbGFjZW1lbnQnO1xuaW1wb3J0IHtzZWxmQm9hcmR9IGZyb20gJy4uLy4uL2luZGV4JztcblxuZnVuY3Rpb24gbW92ZVNoaXBEaXYoc2hpcCwgY2VsbCwgb3JpZW50YXRpb24sIGxlbmd0aCkge1xuICAgIGlmKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGNvbnN0IG5ld0JvdHRvbSA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpO1xuICAgICAgICBjb25zdCBuZXdUb3AgPSBuZXdCb3R0b20gLSAobGVuZ3RoIC0gMSkgKiAxMDtcbiAgICAgICAgaWYobmV3VG9wIDwgMCkgcmV0dXJuO1xuXG4gICAgICAgIHN0eWxlU2hpcChzaGlwLCAndmVydGljYWwnLCBuZXdUb3AsIG5ld0JvdHRvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3UmlnaHQgPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKTtcbiAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihuZXdSaWdodCAvIDEwKTtcbiAgICAgICAgY29uc3QgbmV3TGVmdCA9IG5ld1JpZ2h0IC0gKGxlbmd0aCAtIDEpO1xuICAgICAgICBpZihuZXdMZWZ0IDwgcm93ICogMTApIHJldHVybjtcblxuICAgICAgICBzdHlsZVNoaXAoc2hpcCwgJ2hvcml6b250YWwnLCBuZXdMZWZ0LCBuZXdSaWdodCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdihvcmllbnRhdGlvbiwgbGVuZ3RoLCBlbmQpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgcG9zaXRpb24gPSBlbmQ7XG5cbiAgICBjb25zdCBkZWNyZW1lbnQgPSBvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IDEwIDogMTtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKyspIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgICAgICBwb3NpdGlvbiAtPSBkZWNyZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGFyZVZhbGlkUG9zaXRpb25zKG5ld1Bvc2l0aW9ucywgb2xkUG9zaXRpb25zKSB7XG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9ucy5ldmVyeShuZXdQb3NpdGlvbiA9PiB7XG4gICAgICAgIC8vIGVhY2ggcG9zaXRpb24gbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3Igb25lIG9mIHByZXZpb3VzIHBvc2l0aW9uc1xuICAgICAgICByZXR1cm4gKHNlbGZCb2FyZC5ib2FyZEFycmF5W25ld1Bvc2l0aW9uXSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfHwgb2xkUG9zaXRpb25zLmluY2x1ZGVzKG5ld1Bvc2l0aW9uKVxuICAgICAgICApXG4gICAgfSk7XG59XG5cbmV4cG9ydCAge21vdmVTaGlwRGl2LCBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdiwgYXJlVmFsaWRQb3NpdGlvbnN9OyIsImltcG9ydCB7c2VsZkJvYXJkLCBzZWxmQm9hcmREaXZ9IGZyb20gJy4uLy4uL2luZGV4JztcbmltcG9ydCB7YXJlVmFsaWRQb3NpdGlvbnMsIGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2LCBtb3ZlU2hpcERpdn0gZnJvbSAnLi9TaGlwRGl2TW92ZW1lbnRIYW5kbGVyJztcblxuLy8gZHJhZ2dhYmxlIGV2ZW50IGxpc3RlbmVyc1xuZnVuY3Rpb24gc2hpcERpdkxpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaGlwRGl2cyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcCcpO1xuICAgIHNoaXBEaXZzLmZvckVhY2goc2hpcCA9PiBzaGlwLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGRyYWdTdGFydCkpO1xuICAgIHNoaXBEaXZzLmZvckVhY2goc2hpcCA9PiBzaGlwLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBkcmFnRW5kKSk7XG59XG5cbi8vIGNlbGwgZXZlbnQgbGlzdGVuZXJzXG5mdW5jdGlvbiBjZWxsTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGNlbGxzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJyk7XG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBkcmFnT3ZlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGRyYWdFbnRlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGRyYWdMZWF2ZSkpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBkcmFnRHJvcCkpO1xufVxuXG5mdW5jdGlvbiBhZGREcmFnRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgc2hpcERpdkxpc3RlbmVycygpO1xuICAgIGNlbGxMaXN0ZW5lcnMoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHNoaXBzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaGlwJyk7XG4gICAgY29uc3QgY2VsbHMgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvckFsbCgnLmNlbGwnKTtcbiAgICAvLyBkcmFnZ2FibGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IHNoaXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KSk7XG4gICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IHNoaXAucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGRyYWdFbmQpKTtcblxuICAgIC8vIGNlbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBkcmFnT3ZlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGRyYWdFbnRlcikpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGRyYWdMZWF2ZSkpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBkcmFnRHJvcCkpO1xufVxuXG4vLyBEcmFnZ2luZyBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICBjb25zb2xlLmxvZygnc3RhcnQnKTtcbiAgICBjb25zdCBzaGlwTnVtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2hpcCcpO1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0XCIsIHNoaXBOdW0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGRyYWdFbmQoKSB7XG4gICAgY29uc29sZS5sb2coJ2VuZCcpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIGRyYWdPdmVyKGUpIHtcbiAgICBjb25zb2xlLmxvZygnb3ZlcicpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gZHJhZ0VudGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdlbnRlcicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnaG92ZXJlZCcpO1xufVxuXG5mdW5jdGlvbiBkcmFnTGVhdmUoKSB7XG4gICAgY29uc29sZS5sb2coJ2xlYXZlJyk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSAnY2VsbCc7XG59XG5cbmZ1bmN0aW9uIGRyYWdEcm9wKGUpIHtcbiAgICBjb25zb2xlLmxvZygnZHJvcCcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBkYXRhID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIik7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSAnY2VsbCc7XG4gICAgY29uc3Qgc2hpcCA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yKGAuc2hpcFtkYXRhLXNoaXA9JyR7ZGF0YX0nXWApO1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzO1xuICAgIGNvbnNvbGUubG9nKHNoaXAsIGNlbGwpO1xuICAgIGhhbmRsZURyb3Aoc2hpcCwgY2VsbCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURyb3Aoc2hpcCwgY2VsbCkge1xuICAgIC8vIG1vdmUgdGhlIGRpdlxuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gWy4uLnNoaXAuY2xhc3NMaXN0XS5pbmNsdWRlcygnaG9yaXpvbnRhbCcpID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICBjb25zdCBsZW5ndGggPSBzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1sZW5ndGgnKTtcblxuICAgIC8vIGdldCBvbGQgZW5kIGFuZCBwb3NpdGlvbnNcbiAgICBjb25zdCBvbGRFbmQgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmlnaHQnKSlcbiAgICAgICAgOiBwYXJzZUludChzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1ib3R0b20nKSk7XG4gICAgY29uc3Qgb2xkUG9zaXRpb25zID0gZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYob3JpZW50YXRpb24sIGxlbmd0aCwgb2xkRW5kKTtcbiAgICBjb25zb2xlLmxvZyhvbGRFbmQsIG9sZFBvc2l0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBpZiBtb3ZpbmcgdGhpcyBkaXYgd2lsbCBjYXVzZSBhbnkgb2YgdGhlIHBvc2l0aW9ucyB0byBvdmVybGFwXG4gICAgY29uc3QgbmV3RW5kID0gcGFyc2VJbnQoY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5JykpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2KG9yaWVudGF0aW9uLCBsZW5ndGgsIG5ld0VuZCk7XG5cbiAgICBpZighYXJlVmFsaWRQb3NpdGlvbnMobmV3UG9zaXRpb25zLCBvbGRQb3NpdGlvbnMpKSByZXR1cm47XG4gICAgY29uc29sZS5sb2cobmV3RW5kLCBuZXdQb3NpdGlvbnMpO1xuXG4gICAgbW92ZVNoaXBEaXYoc2hpcCwgY2VsbCwgb3JpZW50YXRpb24sIGxlbmd0aCk7XG5cbiAgICBjb25zdCBzaGlwSW5kZXggPSBwYXJzZUludChzaGlwLmdldEF0dHJpYnV0ZSgnZGF0YS1zaGlwJykpO1xuICAgIGNvbnNvbGUubG9nKHNoaXBJbmRleCwgb2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpO1xuICAgIHNlbGZCb2FyZC51cGRhdGVTaGlwKHNoaXBJbmRleCwgb2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpO1xufVxuXG5leHBvcnQge2FkZERyYWdFdmVudExpc3RlbmVycywgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzLCBzaGlwRGl2TGlzdGVuZXJzfTtcbiIsImltcG9ydCBHYW1lQm9hcmQgZnJvbSAnLi9tb2R1bGVzL0ZhY3Rvcmllcy9HYW1lQm9hcmQnO1xuaW1wb3J0IHJlbmRlckJvYXJkIGZyb20gJy4vbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vQm9hcmREaXNwbGF5JztcbmltcG9ydCBwbGF5Um91bmQgZnJvbSAnLi9tb2R1bGVzL0dhbWVMb29wJztcbmltcG9ydCBzaGlwUGxhY2VtZW50IGZyb20gJy4vbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudCc7XG5pbXBvcnQge1xuICAgIGFkZERyYWdFdmVudExpc3RlbmVycyxcbiAgICByZW1vdmVEcmFnRXZlbnRMaXN0ZW5lcnMsXG4gICAgc2hpcERpdkxpc3RlbmVyc1xufSBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudCc7XG5pbXBvcnQge3BsYWNlQWxsU2hpcERpdnMsIHJlbW92ZUFsbFNoaXBEaXZzfSBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZQbGFjZW1lbnQnO1xuXG5jb25zdCBzZWxmQm9hcmQgPSBHYW1lQm9hcmQoKTtcbmNvbnN0IG9wcG9uZW50Qm9hcmQgPSBHYW1lQm9hcmQoKTtcblxuY29uc3Qgc2VsZkJvYXJkRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlbGYnKTtcbmNvbnN0IG9wcG9uZW50Qm9hcmREaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3Bwb25lbnQnKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIHBsYWNlbWVudCBvZiBzaGlwc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5sZXQge3NoaXBzLCBvcmllbnRhdGlvbnN9ID0gc2hpcFBsYWNlbWVudC5yYW5kb21QbGFjZW1lbnQoc2VsZkJvYXJkKTtcbnBsYWNlQWxsU2hpcERpdnMoc2hpcHMsIG9yaWVudGF0aW9ucyk7XG5cbnNoaXBQbGFjZW1lbnQucmFuZG9tUGxhY2VtZW50KG9wcG9uZW50Qm9hcmQsIG9wcG9uZW50Qm9hcmREaXYpO1xuXG5jb25zb2xlLmxvZyhzZWxmQm9hcmQpO1xuY29uc29sZS5sb2cob3Bwb25lbnRCb2FyZCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIGRpc3BsYXkgYm9hcmRzIGFmdGVyIHNoaXBzIGFyZSBwbGFjZWRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5yZW5kZXJCb2FyZChzZWxmQm9hcmQuYm9hcmRBcnJheSwgc2VsZkJvYXJkRGl2KTtcbnJlbmRlckJvYXJkKG9wcG9uZW50Qm9hcmQuYm9hcmRBcnJheSwgb3Bwb25lbnRCb2FyZERpdik7XG5cbmFkZERyYWdFdmVudExpc3RlbmVycygpO1xuZXhwb3J0IHtvcHBvbmVudEJvYXJkLCBzZWxmQm9hcmQsIHNlbGZCb2FyZERpdn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogaGFuZGxlIGV2ZW50cyBmb3IgcmFuZG9taXplIHBsYWNlbWVudCwgcmVzZXQgZ2FtZSwgc3RhcnQgZ2FtZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCBnYW1lQ29udHJvbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FtZUNvbnRyb2xzJyk7XG5cbmNvbnN0IHJhbmRvbUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNyYW5kb21CdXR0b24nKTtcbnJhbmRvbUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBzaGlwUGxhY2VtZW50LnJlbW92ZVNoaXBzKHNlbGZCb2FyZCk7XG4gICAgcmVtb3ZlQWxsU2hpcERpdnMoKTtcblxuICAgIGNvbnNvbGUubG9nKHNlbGZCb2FyZC5ib2FyZEFycmF5LCBzZWxmQm9hcmQuc2hpcHMpO1xuICAgIGxldCByZXMgPSBzaGlwUGxhY2VtZW50LnJhbmRvbVBsYWNlbWVudChzZWxmQm9hcmQpO1xuICAgIHBsYWNlQWxsU2hpcERpdnMocmVzLnNoaXBzLCByZXMub3JpZW50YXRpb25zKTtcbiAgICBzaGlwRGl2TGlzdGVuZXJzKCk7XG4gICAgY29uc29sZS5sb2coc2VsZkJvYXJkLmJvYXJkQXJyYXksIHNlbGZCb2FyZC5zaGlwcyk7XG5cbn0pO1xuXG5jb25zdCBzdGFydEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGFydEJ1dHRvbicpO1xuc3RhcnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgb3Bwb25lbnRCb2FyZERpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHBsYXlSb3VuZCk7XG4gICAgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzKCk7XG4gICAgZ2FtZUNvbnRyb2xzLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")}]);