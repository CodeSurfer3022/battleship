!function(n){var i={};function t(o){if(i[o])return i[o].exports;var l=i[o]={i:o,l:!1,exports:{}};return n[o].call(l.exports,l,l.exports,t),l.l=!0,l.exports}t.m=n,t.c=i,t.d=function(n,i,o){t.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,i){if(1&i&&(n=t(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var l in n)t.d(o,l,function(i){return n[i]}.bind(null,l));return o},t.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(i,"a",i),i},t.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},t.p="",t(t.s=2)}([function(module,exports){eval("function Player() {\n    const attack = (board, position) => {\n        board.receiveAttack(position);\n    }\n    return {attack}\n}\n\nmodule.exports = Player;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvUGxheWVyLmpzP2I5NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFBsYXllcigpIHtcbiAgICBjb25zdCBhdHRhY2sgPSAoYm9hcmQsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGJvYXJkLnJlY2VpdmVBdHRhY2socG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge2F0dGFja31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("function Ship(positions) {\n    const positionsHealth = {};\n    positions.forEach(position => positionsHealth[position] = 1);\n\n    const getPositions = () => positionsHealth;\n\n    const hit = (position) => {\n        positionsHealth[position] = 0;\n    }\n    const isSunk = () => {\n        return Object.values(positionsHealth).every(health => health === 0)\n    }\n    return {hit, isSunk, getPositions};\n}\n\nmodule.exports = Ship;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvU2hpcC5qcz9mM2Y5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNoaXAocG9zaXRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb25zSGVhbHRoID0ge307XG4gICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zaXRpb25zSGVhbHRoW3Bvc2l0aW9uXSA9IDEpO1xuXG4gICAgY29uc3QgZ2V0UG9zaXRpb25zID0gKCkgPT4gcG9zaXRpb25zSGVhbHRoO1xuXG4gICAgY29uc3QgaGl0ID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHBvc2l0aW9uc0hlYWx0aFtwb3NpdGlvbl0gPSAwO1xuICAgIH1cbiAgICBjb25zdCBpc1N1bmsgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBvc2l0aW9uc0hlYWx0aCkuZXZlcnkoaGVhbHRoID0+IGhlYWx0aCA9PT0gMClcbiAgICB9XG4gICAgcmV0dXJuIHtoaXQsIGlzU3VuaywgZ2V0UG9zaXRpb25zfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGlwOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"opponentBoard\", function() { return /* binding */ opponentBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoard\", function() { return /* binding */ selfBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoardDiv\", function() { return /* binding */ selfBoardDiv; });\n\n// CONCATENATED MODULE: ./src/modules/Factories/GameBoard.js\nconst Ship = __webpack_require__(1);\n\nfunction GameBoard() {\n    const boardArray = [];\n    const ships = [];\n\n    // Initialize an empty board of size 10 * 10\n    for(let i = 0; i < 100; i ++) {\n        boardArray.push(undefined);\n    }\n\n    const placeShip = (index, positions) => {\n        if(positions.every(position => boardArray[position] === undefined)) {\n            const ship = Ship(positions);\n            positions.forEach(position => boardArray[position] = index);\n            ships.push(ship);\n        } else {\n            console.log(\"one or more positions are occupied\")\n        }\n    }\n\n    const removeAllShips = () => {\n        for(let i = 0; i < 100; i ++) {\n            boardArray.push(undefined);\n        }\n    }\n\n    const updateShip = (index, oldPositions, newPositions) => {\n        // remove ship from old position\n        oldPositions.forEach(position => boardArray[position] = undefined);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // replace old ship with new ship\n        ships[index] = Ship(newPositions);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // place this ship on the boardArray\n        newPositions.forEach(position => boardArray[position] = index);\n    }\n\n    const receiveAttack = (position) => {\n        if(boardArray[position] === undefined) {\n            boardArray[position] = 'miss';\n        } else if (boardArray[position] !== 'miss' && boardArray[position] !== 'hit'){\n            const index = boardArray[position];\n            const hitShip = ships[index];\n            hitShip.hit(position);\n            boardArray[position] = 'hit';\n        }\n    }\n\n    const allShipsSunk = () => {\n        return ships.every(ship => ship.isSunk());\n    }\n\n    return {\n        boardArray,\n        ships,\n        placeShip,\n        removeAllShips,\n        updateShip,\n        receiveAttack,\n        allShipsSunk\n    }\n}\n\n/* harmony default export */ var Factories_GameBoard = (GameBoard);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/BoardDisplay.js\nfunction renderBoard(boardArray, boardDiv) {\n\n    boardArray.forEach( (value, index = 0) => {\n        const cell = document.createElement('div');\n        cell.classList.add('cell');\n        cell.setAttribute('data-key', index);\n        boardDiv.appendChild(cell);\n    })\n}\n\n/* harmony default export */ var BoardDisplay = (renderBoard);\n// EXTERNAL MODULE: ./src/modules/Factories/Player.js\nvar Player = __webpack_require__(0);\nvar Player_default = /*#__PURE__*/__webpack_require__.n(Player);\n\n// CONCATENATED MODULE: ./src/modules/ComputerAttack.js\n\n\nfunction validatePosition(direction, hit, position) {\n    // check if the position is on the board\n    if(position < 0 || position > 99) return undefined;\n\n    // check if on the same row, because rows are wrapped\n    if(direction === 'left' || direction === 'right') {\n        const hitRow = Math.floor(hit / 10);\n        const positionRow = Math.floor(position / 10);\n        if(hitRow !== positionRow) return undefined;\n    }\n\n    // check if position had already been attacked\n    let nextPosition = position\n    let cellValue = selfBoard.boardArray[nextPosition];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        nextPosition = getPositionBasedOnHit(position, direction);\n        cellValue = selfBoard.boardArray[nextPosition];\n    }\n    return nextPosition;\n}\n\nfunction getPositionBasedOnHit(hit, direction) {\n    let position;\n    switch (direction) {\n        case 'up':\n            position = hit - 10;\n            break;\n\n        case 'down':\n            position = hit + 10;\n            break;\n\n        case 'left':\n            position = hit - 1;\n            break;\n\n        case 'right':\n            position = hit + 1;\n    }\n    return validatePosition(direction, hit, position);\n}\n\nfunction getRandomPosition() {\n    let position = Math.floor(Math.random() * 100);\n    let cellValue = selfBoard.boardArray[position];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        position = Math.floor(Math.random() * 100);\n        cellValue = selfBoard.boardArray[position];\n    }\n    return position;\n}\n\nfunction ComputerAttack() {\n    let hit;\n    let directions = ['up', 'down', 'left', 'right'];\n\n    const updateHits = (position) => {\n        hit = position;\n    }\n\n    const updateMiss = () => {\n        if(!hit) return;\n        directions.shift();\n\n        // If we've checked in all directions, setup variables for next hit\n        if(directions.length === 0) {\n            hit = undefined;\n            directions = ['up', 'down', 'left', 'right'];\n        }\n    }\n\n    const getComputerAttackPosition = () => {\n        if(hit) {\n            console.log('inside ' + hit + directions);\n\n            // get a valid position i.e on board and on same column for vertical ships\n            let position =  getPositionBasedOnHit(hit, directions[0]);\n            while (!position) {\n                directions.shift();\n                if(directions.length === 0) {\n                    hit = undefined;\n                    directions = ['up', 'down', 'left', 'right'];\n                    return getRandomPosition();\n                }\n                position = getPositionBasedOnHit(hit, directions[0]);\n            }\n            return position;\n        }\n        return getRandomPosition();\n    }\n\n    return {getComputerAttackPosition, updateMiss, updateHits};\n}\n\n/* harmony default export */ var modules_ComputerAttack = (ComputerAttack);\n// CONCATENATED MODULE: ./src/modules/GameLoop.js\n\n\n\n\nconst human = Player_default()();\nconst computer = Player_default()();\nconst computerAttack = modules_ComputerAttack();\n\nfunction playRound(e) {\n    if(selfBoard.allShipsSunk() || opponentBoard.allShipsSunk()) {\n        const winner = opponentBoard.allShipsSunk() ? 'human' : 'computer';\n        console.log(`winner is ${winner}`);\n        return;\n    }\n    // human's attack on computer\n    let cell = e.target;\n    let position = cell.getAttribute('data-key');\n\n    // Don't play round if user attacks already attacked position\n    if([...cell.classList].includes('hit') || [...cell.classList].includes('miss')) return;\n\n    attack(human, opponentBoard, cell, position);\n\n    // computer's attack on human\n    position = computerAttack.getComputerAttackPosition();\n    console.log(position);\n    cell = selfBoardDiv.querySelector(`div[data-key=\"${position}\"]`);\n\n    const computerResult = attack(computer, selfBoard, cell, position);\n    console.log(computerResult);\n\n    // Update hits and misses so computer can make intelligent guesses next time\n    if(computerResult === 'hit') {\n        computerAttack.updateHits(position);\n    } else {\n        computerAttack.updateMiss(position);\n    }\n}\n\nfunction attack(player, board, cell, position){\n    player.attack(board, position);\n    const result = board.boardArray[position];\n    if (result === 'miss') {\n        cell.classList.add('miss');\n    } else if (result === 'hit'){\n        cell.classList.add('hit');\n    }\n    return result;\n}\n\n/* harmony default export */ var GameLoop = (playRound);\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipPlacement.js\nfunction checkValidHorizontalPosition(unaivalablePositions, position, size) {\n    const row = Math.floor(position / 10);\n    const end = (row + 1) * 10;\n\n    // checking if last position will be in the same row\n    if(position + size - 1 >= end) {\n        return false\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position ++;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction checkValidVerticalPosition(unaivalablePositions, position, size) {\n    const col = position % 10;\n    const end = col + 90;\n\n    // checking if last position will be in the same column\n    if(position + (size - 1) * 10 > end) {\n        return false;\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position += 10;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction isvalidPosition(unaivalablePositions ,position, size, orientation) {\n    if(unaivalablePositions.includes(position)) return false;\n\n    if(orientation === 'horizontal') {\n        return checkValidHorizontalPosition(unaivalablePositions, position, size);\n    } else {\n        return checkValidVerticalPosition(unaivalablePositions, position, size);\n    }\n}\n\nfunction getValidPosition(unavailablePositions, size, orientation) {\n    let position = Math.floor(Math.random() * 100);\n    while(!isvalidPosition(unavailablePositions, position, size, orientation))\n    {\n        position = Math.floor(Math.random() * 100);\n    }\n    return position;\n}\n\nfunction makeShips() {\n    const unavailablePositions = [];\n    const ships = [];\n    const orientations = [];\n    // let's make 5 ships of sizes 1 to 5\n    for(let size = 1; size <= 5; size ++) {\n        let orientation = size % 2 ? 'vertical' : 'horizontal';\n        orientations.push(orientation);\n\n        let ship = [];\n        let position = getValidPosition(unavailablePositions, size, orientation);\n        for(let i = 0; i < size; i ++) {\n            ship.push(position);\n            unavailablePositions.push(position);\n            if(orientation === 'vertical') {\n                position += 10;\n            } else {\n                position ++;\n            }\n        }\n        ships.push(ship);\n    }\n    console.log(ships, orientations);\n    return {ships, orientations};\n}\n\nconst shipPlacement = {\n    randomPlacement(board) {\n        const {ships, orientations} = makeShips();\n        ships.forEach((ship, index= 0 )=> {\n            board.placeShip(index, ship);\n        });\n        return {ships, orientations};\n    },\n    removeShips(board) {\n        board.removeAllShips();\n    }\n}\n\n/* harmony default export */ var ShipPlacement = (shipPlacement);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivPlacement.js\n\n\nfunction styleShip(ship, orientation, start, end) {\n    if(orientation === 'vertical') {\n        ship.setAttribute('data-top', start);\n        ship.setAttribute('data-bottom', end);\n    } else {\n        ship.setAttribute('data-left', start);\n        ship.setAttribute('data-right', end);\n    }\n    const topOffset = Math.floor(start/ 10);\n    const leftOffset = start % 10;\n\n    ship.style.top = `${topOffset * 42}px`;\n    ship.style.left = `${leftOffset * 42}px`;\n}\n\nfunction makeShipDiv(orientation, shipNum, length) {\n    const div = document.createElement('div');\n    div.classList.add('ship');\n    div.draggable = true;\n    div.classList.add(orientation);\n    div.setAttribute('data-ship', shipNum);\n    div.setAttribute('data-length', length);\n    if(orientation === 'vertical') {\n        div.style.width = '40px';\n        div.style.height = `${40 * length}px`;\n    } else {\n        div.style.height = '40px';\n        div.style.width = `${40 * length}px`;\n    }\n    return div;\n}\n\nfunction placeShipDivs(container, shipNum, orientation, length, start, end) {\n    const ship = makeShipDiv(orientation, shipNum, length);\n    styleShip(ship, orientation, start, end);\n    container.appendChild(ship);\n}\n\nfunction placeAllShipDivs(ships, orientations) {\n    ships.forEach((ship, index= 0 )=> {\n        const length = ship.length;\n        const start = ship[0];\n        const end = ship[length - 1];\n        placeShipDivs(selfBoardDiv, `${index}`, orientations[index], length, start, end);\n    });\n}\n\nfunction removeAllShipDivs() {\n    const shipDivs = document.querySelectorAll('.ship');\n    shipDivs.forEach(shipDiv => selfBoardDiv.removeChild(shipDiv));\n}\n\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovementHandler.js\n\n\n\nfunction moveShipDiv(ship, cell, orientation, length) {\n    if(orientation === 'vertical') {\n        const newBottom = cell.getAttribute('data-key');\n        const newTop = newBottom - (length - 1) * 10;\n        if(newTop < 0) return;\n\n        styleShip(ship, 'vertical', newTop, newBottom);\n    } else {\n        const newRight = cell.getAttribute('data-key');\n        const row = Math.floor(newRight / 10);\n        const newLeft = newRight - (length - 1);\n        if(newLeft < row * 10) return;\n\n        styleShip(ship, 'horizontal', newLeft, newRight);\n    }\n}\n\nfunction getPositionsFromShipDiv(orientation, length, end) {\n    const positions = [];\n    let position = end;\n\n    const decrement = orientation === 'vertical' ? 10 : 1;\n\n    for(let i = 0; i < length; i ++) {\n        positions.push(position);\n        position -= decrement;\n    }\n    return positions;\n}\n\nfunction areValidPositions(newPositions, oldPositions) {\n    return newPositions.every(newPosition => {\n        // each position must either be empty or one of previous positions\n        return (selfBoard.boardArray[newPosition] === undefined\n                || oldPositions.includes(newPosition)\n        )\n    });\n}\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovement.js\n\n\n\nfunction addDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.addEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.addEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.addEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.addEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.addEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.addEventListener('drop', dragDrop));\n}\n\nfunction removeDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.removeEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.removeEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.removeEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.removeEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.removeEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.removeEventListener('drop', dragDrop));\n}\n\n// Dragging functions\n\nfunction dragStart(e) {\n    console.log('start');\n    const shipNum = this.getAttribute('data-ship');\n    e.dataTransfer.setData(\"text\", shipNum);\n    setTimeout(() => this.classList.add('hidden'), 0);\n}\n\nfunction dragEnd() {\n    console.log('end');\n    this.classList.remove('hidden');\n}\n\nfunction dragOver(e) {\n    console.log('over');\n    e.preventDefault();\n}\n\nfunction dragEnter() {\n    console.log('enter');\n    this.classList.add('hovered');\n}\n\nfunction dragLeave() {\n    console.log('leave');\n    this.className = 'cell';\n}\n\nfunction dragDrop(e) {\n    console.log('drop');\n    e.preventDefault();\n    console.log(e);\n    const data = e.dataTransfer.getData(\"text\");\n    console.log(data);\n    this.className = 'cell';\n    const ship = selfBoardDiv.querySelector(`.ship[data-ship='${data}']`);\n    const cell = this;\n    console.log(ship, cell);\n    handleDrop(ship, cell);\n}\n\nfunction handleDrop(ship, cell) {\n    // move the div\n    const orientation = [...ship.classList].includes('horizontal') ? 'horizontal' : 'vertical';\n    const length = ship.getAttribute('data-length');\n\n    // get old end and positions\n    const oldEnd = orientation === 'horizontal' ?\n        parseInt(ship.getAttribute('data-right'))\n        : parseInt(ship.getAttribute('data-bottom'));\n    const oldPositions = getPositionsFromShipDiv(orientation, length, oldEnd);\n    console.log(oldEnd, oldPositions);\n\n    // check if moving this div will cause any of the positions to overlap\n    const newEnd = parseInt(cell.getAttribute('data-key'));\n    const newPositions = getPositionsFromShipDiv(orientation, length, newEnd);\n\n    if(!areValidPositions(newPositions, oldPositions)) return;\n    console.log(newEnd, newPositions);\n\n    moveShipDiv(ship, cell, orientation, length);\n\n    const shipIndex = parseInt(ship.getAttribute('data-ship'));\n    console.log(shipIndex, oldPositions, newPositions);\n    selfBoard.updateShip(shipIndex, oldPositions, newPositions);\n}\n\n\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\nconst selfBoard = Factories_GameBoard();\nconst opponentBoard = Factories_GameBoard();\n\nconst selfBoardDiv = document.querySelector('#self');\nconst opponentBoardDiv = document.querySelector('#opponent');\n/******************************************************************************************\n * placement of ships\n *******************************************************************************************/\nlet {ships: src_ships, orientations: src_orientations} = ShipPlacement.randomPlacement(selfBoard);\nplaceAllShipDivs(src_ships, src_orientations);\n\nShipPlacement.randomPlacement(opponentBoard, opponentBoardDiv);\n\nconsole.log(selfBoard);\nconsole.log(opponentBoard);\n\n/******************************************************************************************\n * display boards after ships are placed\n *******************************************************************************************/\n\nBoardDisplay(selfBoard.boardArray, selfBoardDiv);\nBoardDisplay(opponentBoard.boardArray, opponentBoardDiv);\n\nopponentBoardDiv.addEventListener('click', GameLoop);\naddDragEventListeners();\n\n\n/******************************************************************************************\n * handle events for randomize placement, reset game, start game\n *******************************************************************************************/\nconst randomButton = document.querySelector('#randomButton');\nrandomButton.addEventListener('click', () => {\n    ShipPlacement.removeShips(selfBoard);\n    removeAllShipDivs();\n\n    let res = ShipPlacement.randomPlacement(selfBoard);\n    placeAllShipDivs(res.ships, res.orientations);\n});\n\nconst startButton = document.querySelector('#startButton');\nstartButton.addEventListener('click', removeDragEventListeners);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkLmpzPzkyY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheS5qcz8yYzIyIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0NvbXB1dGVyQXR0YWNrLmpzPzY2NmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvR2FtZUxvb3AuanM/M2Y4YSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudC5qcz9mNzQ1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50LmpzPzE2YTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudEhhbmRsZXIuanM/Y2UyMSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcERpdk1vdmVtZW50LmpzP2UyMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsYUFBYSxtQkFBTyxDQUFDLENBQVE7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ3NDO0FBQ1g7O0FBRS9GLGtCQUFrQixtQkFBUztBQUMzQixzQkFBc0IsbUJBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUsseUJBQWMsbUJBQUMsR0FBRyxhQUFhO0FBQ3pDLGdCQUFnQixDQUFDLFNBQUssRUFBRSxnQkFBWTs7QUFFcEMsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1gsWUFBVzs7QUFFWCwyQ0FBMkMsUUFBUztBQUNwRCxxQkFBcUI7QUFDMEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakIsSUFBSSxpQkFBaUI7O0FBRXJCLGNBQWMsYUFBYTtBQUMzQixJQUFJLGdCQUFnQjtBQUNwQixDQUFDOztBQUVEO0FBQ0Esc0NBQXNDLHdCQUF3QiIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2hpcCA9IHJlcXVpcmUoJy4vU2hpcCcpO1xuXG5mdW5jdGlvbiBHYW1lQm9hcmQoKSB7XG4gICAgY29uc3QgYm9hcmRBcnJheSA9IFtdO1xuICAgIGNvbnN0IHNoaXBzID0gW107XG5cbiAgICAvLyBJbml0aWFsaXplIGFuIGVtcHR5IGJvYXJkIG9mIHNpemUgMTAgKiAxMFxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMDA7IGkgKyspIHtcbiAgICAgICAgYm9hcmRBcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGxhY2VTaGlwID0gKGluZGV4LCBwb3NpdGlvbnMpID0+IHtcbiAgICAgICAgaWYocG9zaXRpb25zLmV2ZXJ5KHBvc2l0aW9uID0+IGJvYXJkQXJyYXlbcG9zaXRpb25dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlwID0gU2hpcChwb3NpdGlvbnMpO1xuICAgICAgICAgICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gYm9hcmRBcnJheVtwb3NpdGlvbl0gPSBpbmRleCk7XG4gICAgICAgICAgICBzaGlwcy5wdXNoKHNoaXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvbmUgb3IgbW9yZSBwb3NpdGlvbnMgYXJlIG9jY3VwaWVkXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZW1vdmVBbGxTaGlwcyA9ICgpID0+IHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDEwMDsgaSArKykge1xuICAgICAgICAgICAgYm9hcmRBcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVTaGlwID0gKGluZGV4LCBvbGRQb3NpdGlvbnMsIG5ld1Bvc2l0aW9ucykgPT4ge1xuICAgICAgICAvLyByZW1vdmUgc2hpcCBmcm9tIG9sZCBwb3NpdGlvblxuICAgICAgICBvbGRQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgc2hpcHMuZm9yRWFjaChzaGlwID0+IGNvbnNvbGUubG9nKHNoaXAuZ2V0UG9zaXRpb25zKCkpKTtcbiAgICAgICAgLy8gcmVwbGFjZSBvbGQgc2hpcCB3aXRoIG5ldyBzaGlwXG4gICAgICAgIHNoaXBzW2luZGV4XSA9IFNoaXAobmV3UG9zaXRpb25zKTtcblxuICAgICAgICBzaGlwcy5mb3JFYWNoKHNoaXAgPT4gY29uc29sZS5sb2coc2hpcC5nZXRQb3NpdGlvbnMoKSkpO1xuICAgICAgICAvLyBwbGFjZSB0aGlzIHNoaXAgb24gdGhlIGJvYXJkQXJyYXlcbiAgICAgICAgbmV3UG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gYm9hcmRBcnJheVtwb3NpdGlvbl0gPSBpbmRleCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjZWl2ZUF0dGFjayA9IChwb3NpdGlvbikgPT4ge1xuICAgICAgICBpZihib2FyZEFycmF5W3Bvc2l0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBib2FyZEFycmF5W3Bvc2l0aW9uXSA9ICdtaXNzJztcbiAgICAgICAgfSBlbHNlIGlmIChib2FyZEFycmF5W3Bvc2l0aW9uXSAhPT0gJ21pc3MnICYmIGJvYXJkQXJyYXlbcG9zaXRpb25dICE9PSAnaGl0Jyl7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGJvYXJkQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgY29uc3QgaGl0U2hpcCA9IHNoaXBzW2luZGV4XTtcbiAgICAgICAgICAgIGhpdFNoaXAuaGl0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGJvYXJkQXJyYXlbcG9zaXRpb25dID0gJ2hpdCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGxTaGlwc1N1bmsgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBzaGlwcy5ldmVyeShzaGlwID0+IHNoaXAuaXNTdW5rKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGJvYXJkQXJyYXksXG4gICAgICAgIHNoaXBzLFxuICAgICAgICBwbGFjZVNoaXAsXG4gICAgICAgIHJlbW92ZUFsbFNoaXBzLFxuICAgICAgICB1cGRhdGVTaGlwLFxuICAgICAgICByZWNlaXZlQXR0YWNrLFxuICAgICAgICBhbGxTaGlwc1N1bmtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdhbWVCb2FyZDtcbiIsImZ1bmN0aW9uIHJlbmRlckJvYXJkKGJvYXJkQXJyYXksIGJvYXJkRGl2KSB7XG5cbiAgICBib2FyZEFycmF5LmZvckVhY2goICh2YWx1ZSwgaW5kZXggPSAwKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKCdjZWxsJyk7XG4gICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdkYXRhLWtleScsIGluZGV4KTtcbiAgICAgICAgYm9hcmREaXYuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyQm9hcmQ7IiwiaW1wb3J0IHtzZWxmQm9hcmR9IGZyb20gJy4uL2luZGV4JztcblxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIGhpdCwgcG9zaXRpb24pIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgcG9zaXRpb24gaXMgb24gdGhlIGJvYXJkXG4gICAgaWYocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gOTkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBjaGVjayBpZiBvbiB0aGUgc2FtZSByb3csIGJlY2F1c2Ugcm93cyBhcmUgd3JhcHBlZFxuICAgIGlmKGRpcmVjdGlvbiA9PT0gJ2xlZnQnIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBjb25zdCBoaXRSb3cgPSBNYXRoLmZsb29yKGhpdCAvIDEwKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25Sb3cgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gMTApO1xuICAgICAgICBpZihoaXRSb3cgIT09IHBvc2l0aW9uUm93KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHBvc2l0aW9uIGhhZCBhbHJlYWR5IGJlZW4gYXR0YWNrZWRcbiAgICBsZXQgbmV4dFBvc2l0aW9uID0gcG9zaXRpb25cbiAgICBsZXQgY2VsbFZhbHVlID0gc2VsZkJvYXJkLmJvYXJkQXJyYXlbbmV4dFBvc2l0aW9uXTtcbiAgICB3aGlsZShjZWxsVmFsdWUgPT09ICdtaXNzJyB8fCBjZWxsVmFsdWUgPT09ICdoaXQnKSB7XG4gICAgICAgIG5leHRQb3NpdGlvbiA9IGdldFBvc2l0aW9uQmFzZWRPbkhpdChwb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICAgICAgY2VsbFZhbHVlID0gc2VsZkJvYXJkLmJvYXJkQXJyYXlbbmV4dFBvc2l0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25CYXNlZE9uSGl0KGhpdCwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IHBvc2l0aW9uO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaGl0IC0gMTA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaGl0ICsgMTA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaGl0IC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaGl0ICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlUG9zaXRpb24oZGlyZWN0aW9uLCBoaXQsIHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tUG9zaXRpb24oKSB7XG4gICAgbGV0IHBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICBsZXQgY2VsbFZhbHVlID0gc2VsZkJvYXJkLmJvYXJkQXJyYXlbcG9zaXRpb25dO1xuICAgIHdoaWxlKGNlbGxWYWx1ZSA9PT0gJ21pc3MnIHx8IGNlbGxWYWx1ZSA9PT0gJ2hpdCcpIHtcbiAgICAgICAgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgICAgICBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gQ29tcHV0ZXJBdHRhY2soKSB7XG4gICAgbGV0IGhpdDtcbiAgICBsZXQgZGlyZWN0aW9ucyA9IFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0J107XG5cbiAgICBjb25zdCB1cGRhdGVIaXRzID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGhpdCA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZU1pc3MgPSAoKSA9PiB7XG4gICAgICAgIGlmKCFoaXQpIHJldHVybjtcbiAgICAgICAgZGlyZWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGNoZWNrZWQgaW4gYWxsIGRpcmVjdGlvbnMsIHNldHVwIHZhcmlhYmxlcyBmb3IgbmV4dCBoaXRcbiAgICAgICAgaWYoZGlyZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGhpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCddO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q29tcHV0ZXJBdHRhY2tQb3NpdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYoaGl0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW5zaWRlICcgKyBoaXQgKyBkaXJlY3Rpb25zKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGEgdmFsaWQgcG9zaXRpb24gaS5lIG9uIGJvYXJkIGFuZCBvbiBzYW1lIGNvbHVtbiBmb3IgdmVydGljYWwgc2hpcHNcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9ICBnZXRQb3NpdGlvbkJhc2VkT25IaXQoaGl0LCBkaXJlY3Rpb25zWzBdKTtcbiAgICAgICAgICAgIHdoaWxlICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zID0gWyd1cCcsICdkb3duJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhbmRvbVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZ2V0UG9zaXRpb25CYXNlZE9uSGl0KGhpdCwgZGlyZWN0aW9uc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFJhbmRvbVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtnZXRDb21wdXRlckF0dGFja1Bvc2l0aW9uLCB1cGRhdGVNaXNzLCB1cGRhdGVIaXRzfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcHV0ZXJBdHRhY2s7IiwiaW1wb3J0IFBsYXllciBmcm9tICcuL0ZhY3Rvcmllcy9QbGF5ZXInO1xuaW1wb3J0IHtzZWxmQm9hcmQsIG9wcG9uZW50Qm9hcmQsIHNlbGZCb2FyZERpdn0gZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IENvbXB1dGVyQXR0YWNrIGZyb20gJy4vQ29tcHV0ZXJBdHRhY2snO1xuXG5jb25zdCBodW1hbiA9IFBsYXllcigpO1xuY29uc3QgY29tcHV0ZXIgPSBQbGF5ZXIoKTtcbmNvbnN0IGNvbXB1dGVyQXR0YWNrID0gQ29tcHV0ZXJBdHRhY2soKTtcblxuZnVuY3Rpb24gcGxheVJvdW5kKGUpIHtcbiAgICBpZihzZWxmQm9hcmQuYWxsU2hpcHNTdW5rKCkgfHwgb3Bwb25lbnRCb2FyZC5hbGxTaGlwc1N1bmsoKSkge1xuICAgICAgICBjb25zdCB3aW5uZXIgPSBvcHBvbmVudEJvYXJkLmFsbFNoaXBzU3VuaygpID8gJ2h1bWFuJyA6ICdjb21wdXRlcic7XG4gICAgICAgIGNvbnNvbGUubG9nKGB3aW5uZXIgaXMgJHt3aW5uZXJ9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaHVtYW4ncyBhdHRhY2sgb24gY29tcHV0ZXJcbiAgICBsZXQgY2VsbCA9IGUudGFyZ2V0O1xuICAgIGxldCBwb3NpdGlvbiA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpO1xuXG4gICAgLy8gRG9uJ3QgcGxheSByb3VuZCBpZiB1c2VyIGF0dGFja3MgYWxyZWFkeSBhdHRhY2tlZCBwb3NpdGlvblxuICAgIGlmKFsuLi5jZWxsLmNsYXNzTGlzdF0uaW5jbHVkZXMoJ2hpdCcpIHx8IFsuLi5jZWxsLmNsYXNzTGlzdF0uaW5jbHVkZXMoJ21pc3MnKSkgcmV0dXJuO1xuXG4gICAgYXR0YWNrKGh1bWFuLCBvcHBvbmVudEJvYXJkLCBjZWxsLCBwb3NpdGlvbik7XG5cbiAgICAvLyBjb21wdXRlcidzIGF0dGFjayBvbiBodW1hblxuICAgIHBvc2l0aW9uID0gY29tcHV0ZXJBdHRhY2suZ2V0Q29tcHV0ZXJBdHRhY2tQb3NpdGlvbigpO1xuICAgIGNvbnNvbGUubG9nKHBvc2l0aW9uKTtcbiAgICBjZWxsID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3IoYGRpdltkYXRhLWtleT1cIiR7cG9zaXRpb259XCJdYCk7XG5cbiAgICBjb25zdCBjb21wdXRlclJlc3VsdCA9IGF0dGFjayhjb21wdXRlciwgc2VsZkJvYXJkLCBjZWxsLCBwb3NpdGlvbik7XG4gICAgY29uc29sZS5sb2coY29tcHV0ZXJSZXN1bHQpO1xuXG4gICAgLy8gVXBkYXRlIGhpdHMgYW5kIG1pc3NlcyBzbyBjb21wdXRlciBjYW4gbWFrZSBpbnRlbGxpZ2VudCBndWVzc2VzIG5leHQgdGltZVxuICAgIGlmKGNvbXB1dGVyUmVzdWx0ID09PSAnaGl0Jykge1xuICAgICAgICBjb21wdXRlckF0dGFjay51cGRhdGVIaXRzKHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wdXRlckF0dGFjay51cGRhdGVNaXNzKHBvc2l0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjayhwbGF5ZXIsIGJvYXJkLCBjZWxsLCBwb3NpdGlvbil7XG4gICAgcGxheWVyLmF0dGFjayhib2FyZCwgcG9zaXRpb24pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGJvYXJkLmJvYXJkQXJyYXlbcG9zaXRpb25dO1xuICAgIGlmIChyZXN1bHQgPT09ICdtaXNzJykge1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ21pc3MnKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gJ2hpdCcpe1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ2hpdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBwbGF5Um91bmQ7IiwiZnVuY3Rpb24gY2hlY2tWYWxpZEhvcml6b250YWxQb3NpdGlvbih1bmFpdmFsYWJsZVBvc2l0aW9ucywgcG9zaXRpb24sIHNpemUpIHtcbiAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gMTApO1xuICAgIGNvbnN0IGVuZCA9IChyb3cgKyAxKSAqIDEwO1xuXG4gICAgLy8gY2hlY2tpbmcgaWYgbGFzdCBwb3NpdGlvbiB3aWxsIGJlIGluIHRoZSBzYW1lIHJvd1xuICAgIGlmKHBvc2l0aW9uICsgc2l6ZSAtIDEgPj0gZW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBwb3NpdGlvbnMgd2l0aCB0aGlzIHN0YXJ0aW5nIHBvc2l0aW9uIGFyZSBhdmFpbGFibGVcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArKykge1xuICAgICAgICBwb3NpdGlvbiArKztcbiAgICAgICAgaWYodW5haXZhbGFibGVQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRWZXJ0aWNhbFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSkge1xuICAgIGNvbnN0IGNvbCA9IHBvc2l0aW9uICUgMTA7XG4gICAgY29uc3QgZW5kID0gY29sICsgOTA7XG5cbiAgICAvLyBjaGVja2luZyBpZiBsYXN0IHBvc2l0aW9uIHdpbGwgYmUgaW4gdGhlIHNhbWUgY29sdW1uXG4gICAgaWYocG9zaXRpb24gKyAoc2l6ZSAtIDEpICogMTAgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBwb3NpdGlvbnMgd2l0aCB0aGlzIHN0YXJ0aW5nIHBvc2l0aW9uIGFyZSBhdmFpbGFibGVcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArKykge1xuICAgICAgICBwb3NpdGlvbiArPSAxMDtcbiAgICAgICAgaWYodW5haXZhbGFibGVQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzdmFsaWRQb3NpdGlvbih1bmFpdmFsYWJsZVBvc2l0aW9ucyAscG9zaXRpb24sIHNpemUsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYodW5haXZhbGFibGVQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZihvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgIHJldHVybiBjaGVja1ZhbGlkSG9yaXpvbnRhbFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrVmFsaWRWZXJ0aWNhbFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZFBvc2l0aW9uKHVuYXZhaWxhYmxlUG9zaXRpb25zLCBzaXplLCBvcmllbnRhdGlvbikge1xuICAgIGxldCBwb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgd2hpbGUoIWlzdmFsaWRQb3NpdGlvbih1bmF2YWlsYWJsZVBvc2l0aW9ucywgcG9zaXRpb24sIHNpemUsIG9yaWVudGF0aW9uKSlcbiAgICB7XG4gICAgICAgIHBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBtYWtlU2hpcHMoKSB7XG4gICAgY29uc3QgdW5hdmFpbGFibGVQb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBzaGlwcyA9IFtdO1xuICAgIGNvbnN0IG9yaWVudGF0aW9ucyA9IFtdO1xuICAgIC8vIGxldCdzIG1ha2UgNSBzaGlwcyBvZiBzaXplcyAxIHRvIDVcbiAgICBmb3IobGV0IHNpemUgPSAxOyBzaXplIDw9IDU7IHNpemUgKyspIHtcbiAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gc2l6ZSAlIDIgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgICBvcmllbnRhdGlvbnMucHVzaChvcmllbnRhdGlvbik7XG5cbiAgICAgICAgbGV0IHNoaXAgPSBbXTtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gZ2V0VmFsaWRQb3NpdGlvbih1bmF2YWlsYWJsZVBvc2l0aW9ucywgc2l6ZSwgb3JpZW50YXRpb24pO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArKykge1xuICAgICAgICAgICAgc2hpcC5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHVuYXZhaWxhYmxlUG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgICAgICAgICAgaWYob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAxMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hpcHMucHVzaChzaGlwKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coc2hpcHMsIG9yaWVudGF0aW9ucyk7XG4gICAgcmV0dXJuIHtzaGlwcywgb3JpZW50YXRpb25zfTtcbn1cblxuY29uc3Qgc2hpcFBsYWNlbWVudCA9IHtcbiAgICByYW5kb21QbGFjZW1lbnQoYm9hcmQpIHtcbiAgICAgICAgY29uc3Qge3NoaXBzLCBvcmllbnRhdGlvbnN9ID0gbWFrZVNoaXBzKCk7XG4gICAgICAgIHNoaXBzLmZvckVhY2goKHNoaXAsIGluZGV4PSAwICk9PiB7XG4gICAgICAgICAgICBib2FyZC5wbGFjZVNoaXAoaW5kZXgsIHNoaXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtzaGlwcywgb3JpZW50YXRpb25zfTtcbiAgICB9LFxuICAgIHJlbW92ZVNoaXBzKGJvYXJkKSB7XG4gICAgICAgIGJvYXJkLnJlbW92ZUFsbFNoaXBzKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzaGlwUGxhY2VtZW50O1xuIiwiaW1wb3J0IHtzZWxmQm9hcmREaXZ9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5mdW5jdGlvbiBzdHlsZVNoaXAoc2hpcCwgb3JpZW50YXRpb24sIHN0YXJ0LCBlbmQpIHtcbiAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS10b3AnLCBzdGFydCk7XG4gICAgICAgIHNoaXAuc2V0QXR0cmlidXRlKCdkYXRhLWJvdHRvbScsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2hpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGVmdCcsIHN0YXJ0KTtcbiAgICAgICAgc2hpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmlnaHQnLCBlbmQpO1xuICAgIH1cbiAgICBjb25zdCB0b3BPZmZzZXQgPSBNYXRoLmZsb29yKHN0YXJ0LyAxMCk7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IHN0YXJ0ICUgMTA7XG5cbiAgICBzaGlwLnN0eWxlLnRvcCA9IGAke3RvcE9mZnNldCAqIDQyfXB4YDtcbiAgICBzaGlwLnN0eWxlLmxlZnQgPSBgJHtsZWZ0T2Zmc2V0ICogNDJ9cHhgO1xufVxuXG5mdW5jdGlvbiBtYWtlU2hpcERpdihvcmllbnRhdGlvbiwgc2hpcE51bSwgbGVuZ3RoKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3NoaXAnKTtcbiAgICBkaXYuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZChvcmllbnRhdGlvbik7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1zaGlwJywgc2hpcE51bSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1sZW5ndGgnLCBsZW5ndGgpO1xuICAgIGlmKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICc0MHB4JztcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAkezQwICogbGVuZ3RofXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzQwcHgnO1xuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHs0MCAqIGxlbmd0aH1weGA7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIHBsYWNlU2hpcERpdnMoY29udGFpbmVyLCBzaGlwTnVtLCBvcmllbnRhdGlvbiwgbGVuZ3RoLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3Qgc2hpcCA9IG1ha2VTaGlwRGl2KG9yaWVudGF0aW9uLCBzaGlwTnVtLCBsZW5ndGgpO1xuICAgIHN0eWxlU2hpcChzaGlwLCBvcmllbnRhdGlvbiwgc3RhcnQsIGVuZCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNoaXApO1xufVxuXG5mdW5jdGlvbiBwbGFjZUFsbFNoaXBEaXZzKHNoaXBzLCBvcmllbnRhdGlvbnMpIHtcbiAgICBzaGlwcy5mb3JFYWNoKChzaGlwLCBpbmRleD0gMCApPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBzaGlwLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzaGlwWzBdO1xuICAgICAgICBjb25zdCBlbmQgPSBzaGlwW2xlbmd0aCAtIDFdO1xuICAgICAgICBwbGFjZVNoaXBEaXZzKHNlbGZCb2FyZERpdiwgYCR7aW5kZXh9YCwgb3JpZW50YXRpb25zW2luZGV4XSwgbGVuZ3RoLCBzdGFydCwgZW5kKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsU2hpcERpdnMoKSB7XG4gICAgY29uc3Qgc2hpcERpdnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcCcpO1xuICAgIHNoaXBEaXZzLmZvckVhY2goc2hpcERpdiA9PiBzZWxmQm9hcmREaXYucmVtb3ZlQ2hpbGQoc2hpcERpdikpO1xufVxuXG5leHBvcnQge3N0eWxlU2hpcCwgcGxhY2VBbGxTaGlwRGl2cywgcmVtb3ZlQWxsU2hpcERpdnN9O1xuIiwiaW1wb3J0IHtzdHlsZVNoaXB9IGZyb20gJy4vU2hpcERpdlBsYWNlbWVudCc7XG5pbXBvcnQge3NlbGZCb2FyZH0gZnJvbSAnLi4vLi4vaW5kZXgnO1xuXG5mdW5jdGlvbiBtb3ZlU2hpcERpdihzaGlwLCBjZWxsLCBvcmllbnRhdGlvbiwgbGVuZ3RoKSB7XG4gICAgaWYob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgY29uc3QgbmV3Qm90dG9tID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Jyk7XG4gICAgICAgIGNvbnN0IG5ld1RvcCA9IG5ld0JvdHRvbSAtIChsZW5ndGggLSAxKSAqIDEwO1xuICAgICAgICBpZihuZXdUb3AgPCAwKSByZXR1cm47XG5cbiAgICAgICAgc3R5bGVTaGlwKHNoaXAsICd2ZXJ0aWNhbCcsIG5ld1RvcCwgbmV3Qm90dG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdSaWdodCA9IGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpO1xuICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKG5ld1JpZ2h0IC8gMTApO1xuICAgICAgICBjb25zdCBuZXdMZWZ0ID0gbmV3UmlnaHQgLSAobGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmKG5ld0xlZnQgPCByb3cgKiAxMCkgcmV0dXJuO1xuXG4gICAgICAgIHN0eWxlU2hpcChzaGlwLCAnaG9yaXpvbnRhbCcsIG5ld0xlZnQsIG5ld1JpZ2h0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2KG9yaWVudGF0aW9uLCBsZW5ndGgsIGVuZCkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGxldCBwb3NpdGlvbiA9IGVuZDtcblxuICAgIGNvbnN0IGRlY3JlbWVudCA9IG9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gMTAgOiAxO1xuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKykge1xuICAgICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICAgIHBvc2l0aW9uIC09IGRlY3JlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gYXJlVmFsaWRQb3NpdGlvbnMobmV3UG9zaXRpb25zLCBvbGRQb3NpdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3UG9zaXRpb25zLmV2ZXJ5KG5ld1Bvc2l0aW9uID0+IHtcbiAgICAgICAgLy8gZWFjaCBwb3NpdGlvbiBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBvbmUgb2YgcHJldmlvdXMgcG9zaXRpb25zXG4gICAgICAgIHJldHVybiAoc2VsZkJvYXJkLmJvYXJkQXJyYXlbbmV3UG9zaXRpb25dID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB8fCBvbGRQb3NpdGlvbnMuaW5jbHVkZXMobmV3UG9zaXRpb24pXG4gICAgICAgIClcbiAgICB9KTtcbn1cblxuZXhwb3J0ICB7bW92ZVNoaXBEaXYsIGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2LCBhcmVWYWxpZFBvc2l0aW9uc307IiwiaW1wb3J0IHtzZWxmQm9hcmQsIHNlbGZCb2FyZERpdn0gZnJvbSAnLi4vLi4vaW5kZXgnO1xuaW1wb3J0IHthcmVWYWxpZFBvc2l0aW9ucywgZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYsIG1vdmVTaGlwRGl2fSBmcm9tICcuL1NoaXBEaXZNb3ZlbWVudEhhbmRsZXInO1xuXG5mdW5jdGlvbiBhZGREcmFnRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc2hpcHMgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvckFsbCgnLnNoaXAnKTtcbiAgICBjb25zdCBjZWxscyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY2VsbCcpO1xuICAgIC8vIGRyYWdnYWJsZSBldmVudCBsaXN0ZW5lcnNcbiAgICBzaGlwcy5mb3JFYWNoKHNoaXAgPT4gc2hpcC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpKTtcbiAgICBzaGlwcy5mb3JFYWNoKHNoaXAgPT4gc2hpcC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgZHJhZ0VuZCkpO1xuXG4gICAgLy8gY2VsbCBldmVudCBsaXN0ZW5lcnNcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGRyYWdPdmVyKSk7XG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgZHJhZ0VudGVyKSk7XG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgZHJhZ0xlYXZlKSk7XG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGRyYWdEcm9wKSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURyYWdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaGlwcyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcCcpO1xuICAgIGNvbnN0IGNlbGxzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJyk7XG4gICAgLy8gZHJhZ2dhYmxlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGRyYWdTdGFydCkpO1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBkcmFnRW5kKSk7XG5cbiAgICAvLyBjZWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ092ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBkcmFnRW50ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgZHJhZ0Ryb3ApKTtcbn1cblxuLy8gRHJhZ2dpbmcgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG4gICAgY29uc29sZS5sb2coJ3N0YXJ0Jyk7XG4gICAgY29uc3Qgc2hpcE51bSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXNoaXAnKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBzaGlwTnVtKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyksIDApO1xufVxuXG5mdW5jdGlvbiBkcmFnRW5kKCkge1xuICAgIGNvbnNvbGUubG9nKCdlbmQnKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xufVxuXG5mdW5jdGlvbiBkcmFnT3ZlcihlKSB7XG4gICAgY29uc29sZS5sb2coJ292ZXInKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIGRyYWdFbnRlcigpIHtcbiAgICBjb25zb2xlLmxvZygnZW50ZXInKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hvdmVyZWQnKTtcbn1cblxuZnVuY3Rpb24gZHJhZ0xlYXZlKCkge1xuICAgIGNvbnNvbGUubG9nKCdsZWF2ZScpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gJ2NlbGwnO1xufVxuXG5mdW5jdGlvbiBkcmFnRHJvcChlKSB7XG4gICAgY29uc29sZS5sb2coJ2Ryb3AnKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc29sZS5sb2coZSk7XG4gICAgY29uc3QgZGF0YSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0XCIpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gJ2NlbGwnO1xuICAgIGNvbnN0IHNoaXAgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvcihgLnNoaXBbZGF0YS1zaGlwPScke2RhdGF9J11gKTtcbiAgICBjb25zdCBjZWxsID0gdGhpcztcbiAgICBjb25zb2xlLmxvZyhzaGlwLCBjZWxsKTtcbiAgICBoYW5kbGVEcm9wKHNoaXAsIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEcm9wKHNoaXAsIGNlbGwpIHtcbiAgICAvLyBtb3ZlIHRoZSBkaXZcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IFsuLi5zaGlwLmNsYXNzTGlzdF0uaW5jbHVkZXMoJ2hvcml6b250YWwnKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgY29uc3QgbGVuZ3RoID0gc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGVuZ3RoJyk7XG5cbiAgICAvLyBnZXQgb2xkIGVuZCBhbmQgcG9zaXRpb25zXG4gICAgY29uc3Qgb2xkRW5kID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgIHBhcnNlSW50KHNoaXAuZ2V0QXR0cmlidXRlKCdkYXRhLXJpZ2h0JykpXG4gICAgICAgIDogcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYm90dG9tJykpO1xuICAgIGNvbnN0IG9sZFBvc2l0aW9ucyA9IGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2KG9yaWVudGF0aW9uLCBsZW5ndGgsIG9sZEVuZCk7XG4gICAgY29uc29sZS5sb2cob2xkRW5kLCBvbGRQb3NpdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbW92aW5nIHRoaXMgZGl2IHdpbGwgY2F1c2UgYW55IG9mIHRoZSBwb3NpdGlvbnMgdG8gb3ZlcmxhcFxuICAgIGNvbnN0IG5ld0VuZCA9IHBhcnNlSW50KGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbnMgPSBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdihvcmllbnRhdGlvbiwgbGVuZ3RoLCBuZXdFbmQpO1xuXG4gICAgaWYoIWFyZVZhbGlkUG9zaXRpb25zKG5ld1Bvc2l0aW9ucywgb2xkUG9zaXRpb25zKSkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKG5ld0VuZCwgbmV3UG9zaXRpb25zKTtcblxuICAgIG1vdmVTaGlwRGl2KHNoaXAsIGNlbGwsIG9yaWVudGF0aW9uLCBsZW5ndGgpO1xuXG4gICAgY29uc3Qgc2hpcEluZGV4ID0gcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2hpcCcpKTtcbiAgICBjb25zb2xlLmxvZyhzaGlwSW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKTtcbiAgICBzZWxmQm9hcmQudXBkYXRlU2hpcChzaGlwSW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKTtcbn1cblxuZXhwb3J0IHthZGREcmFnRXZlbnRMaXN0ZW5lcnMsIHJlbW92ZURyYWdFdmVudExpc3RlbmVyc307XG4iLCJpbXBvcnQgR2FtZUJvYXJkIGZyb20gJy4vbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkJztcbmltcG9ydCByZW5kZXJCb2FyZCBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheSc7XG5pbXBvcnQgcGxheVJvdW5kIGZyb20gJy4vbW9kdWxlcy9HYW1lTG9vcCc7XG5pbXBvcnQgc2hpcFBsYWNlbWVudCBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBQbGFjZW1lbnQnO1xuaW1wb3J0IHthZGREcmFnRXZlbnRMaXN0ZW5lcnMsIHJlbW92ZURyYWdFdmVudExpc3RlbmVyc30gZnJvbSAnLi9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2TW92ZW1lbnQnO1xuaW1wb3J0IHtwbGFjZUFsbFNoaXBEaXZzLCByZW1vdmVBbGxTaGlwRGl2c30gZnJvbSAnLi9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50JztcblxuY29uc3Qgc2VsZkJvYXJkID0gR2FtZUJvYXJkKCk7XG5jb25zdCBvcHBvbmVudEJvYXJkID0gR2FtZUJvYXJkKCk7XG5cbmNvbnN0IHNlbGZCb2FyZERpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWxmJyk7XG5jb25zdCBvcHBvbmVudEJvYXJkRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI29wcG9uZW50Jyk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBwbGFjZW1lbnQgb2Ygc2hpcHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xubGV0IHtzaGlwcywgb3JpZW50YXRpb25zfSA9IHNoaXBQbGFjZW1lbnQucmFuZG9tUGxhY2VtZW50KHNlbGZCb2FyZCk7XG5wbGFjZUFsbFNoaXBEaXZzKHNoaXBzLCBvcmllbnRhdGlvbnMpO1xuXG5zaGlwUGxhY2VtZW50LnJhbmRvbVBsYWNlbWVudChvcHBvbmVudEJvYXJkLCBvcHBvbmVudEJvYXJkRGl2KTtcblxuY29uc29sZS5sb2coc2VsZkJvYXJkKTtcbmNvbnNvbGUubG9nKG9wcG9uZW50Qm9hcmQpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBkaXNwbGF5IGJvYXJkcyBhZnRlciBzaGlwcyBhcmUgcGxhY2VkXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxucmVuZGVyQm9hcmQoc2VsZkJvYXJkLmJvYXJkQXJyYXksIHNlbGZCb2FyZERpdik7XG5yZW5kZXJCb2FyZChvcHBvbmVudEJvYXJkLmJvYXJkQXJyYXksIG9wcG9uZW50Qm9hcmREaXYpO1xuXG5vcHBvbmVudEJvYXJkRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcGxheVJvdW5kKTtcbmFkZERyYWdFdmVudExpc3RlbmVycygpO1xuZXhwb3J0IHtvcHBvbmVudEJvYXJkLCBzZWxmQm9hcmQsIHNlbGZCb2FyZERpdn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogaGFuZGxlIGV2ZW50cyBmb3IgcmFuZG9taXplIHBsYWNlbWVudCwgcmVzZXQgZ2FtZSwgc3RhcnQgZ2FtZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCByYW5kb21CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcmFuZG9tQnV0dG9uJyk7XG5yYW5kb21CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2hpcFBsYWNlbWVudC5yZW1vdmVTaGlwcyhzZWxmQm9hcmQpO1xuICAgIHJlbW92ZUFsbFNoaXBEaXZzKCk7XG5cbiAgICBsZXQgcmVzID0gc2hpcFBsYWNlbWVudC5yYW5kb21QbGFjZW1lbnQoc2VsZkJvYXJkKTtcbiAgICBwbGFjZUFsbFNoaXBEaXZzKHJlcy5zaGlwcywgcmVzLm9yaWVudGF0aW9ucyk7XG59KTtcblxuY29uc3Qgc3RhcnRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnRCdXR0b24nKTtcbnN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")}]);