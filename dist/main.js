!function(n){var i={};function t(o){if(i[o])return i[o].exports;var c=i[o]={i:o,l:!1,exports:{}};return n[o].call(c.exports,c,c.exports,t),c.l=!0,c.exports}t.m=n,t.c=i,t.d=function(n,i,o){t.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,i){if(1&i&&(n=t(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var c in n)t.d(o,c,function(i){return n[i]}.bind(null,c));return o},t.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(i,"a",i),i},t.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},t.p="",t(t.s=2)}([function(module,exports){eval("function Player() {\n    const attack = (board, position) => {\n        board.receiveAttack(position);\n    }\n    return {attack}\n}\n\nmodule.exports = Player;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvUGxheWVyLmpzP2I5NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFBsYXllcigpIHtcbiAgICBjb25zdCBhdHRhY2sgPSAoYm9hcmQsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGJvYXJkLnJlY2VpdmVBdHRhY2socG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge2F0dGFja31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("function Ship(positions) {\n    const positionsHealth = {};\n    positions.forEach(position => positionsHealth[position] = 1);\n\n    const getPositions = () => positionsHealth;\n\n    const hit = (position) => {\n        positionsHealth[position] = 0;\n    }\n    const isSunk = () => {\n        return Object.values(positionsHealth).every(health => health === 0)\n    }\n    return {hit, isSunk, getPositions};\n}\n\nmodule.exports = Ship;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvU2hpcC5qcz9mM2Y5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNoaXAocG9zaXRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb25zSGVhbHRoID0ge307XG4gICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zaXRpb25zSGVhbHRoW3Bvc2l0aW9uXSA9IDEpO1xuXG4gICAgY29uc3QgZ2V0UG9zaXRpb25zID0gKCkgPT4gcG9zaXRpb25zSGVhbHRoO1xuXG4gICAgY29uc3QgaGl0ID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHBvc2l0aW9uc0hlYWx0aFtwb3NpdGlvbl0gPSAwO1xuICAgIH1cbiAgICBjb25zdCBpc1N1bmsgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBvc2l0aW9uc0hlYWx0aCkuZXZlcnkoaGVhbHRoID0+IGhlYWx0aCA9PT0gMClcbiAgICB9XG4gICAgcmV0dXJuIHtoaXQsIGlzU3VuaywgZ2V0UG9zaXRpb25zfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGlwOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"opponentBoard\", function() { return /* binding */ opponentBoard; });\n__webpack_require__.d(__webpack_exports__, \"selfBoard\", function() { return /* binding */ selfBoard; });\n__webpack_require__.d(__webpack_exports__, \"opponentBoardDiv\", function() { return /* binding */ opponentBoardDiv; });\n__webpack_require__.d(__webpack_exports__, \"selfBoardDiv\", function() { return /* binding */ selfBoardDiv; });\n\n// CONCATENATED MODULE: ./src/modules/Factories/GameBoard.js\nconst Ship = __webpack_require__(1);\n\nfunction GameBoard() {\n    const boardArray = [];\n    let ships = [];\n\n    // Initialize an empty board of size 10 * 10\n    for(let i = 0; i < 100; i ++) {\n        boardArray.push(undefined);\n    }\n\n    const placeShip = (index, positions) => {\n        if(positions.every(position => boardArray[position] === undefined)) {\n            const ship = Ship(positions);\n            positions.forEach(position => boardArray[position] = index);\n            ships.push(ship);\n        } else {\n            console.log(\"one or more positions are occupied\")\n        }\n    }\n\n    const removeAllShips = () => {\n        for(let i = 0; i < 100; i ++) {\n            boardArray[i] = undefined;\n            ships.length = 0;\n        }\n    }\n\n    const updateShip = (index, oldPositions, newPositions) => {\n        // remove ship from old position\n        oldPositions.forEach(position => boardArray[position] = undefined);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // replace old ship with new ship\n        ships[index] = Ship(newPositions);\n\n        ships.forEach(ship => console.log(ship.getPositions()));\n        // place this ship on the boardArray\n        newPositions.forEach(position => boardArray[position] = index);\n    }\n\n    const receiveAttack = (position) => {\n        if(boardArray[position] === undefined) {\n            boardArray[position] = 'miss';\n        } else if (boardArray[position] !== 'miss' && boardArray[position] !== 'hit'){\n            const index = boardArray[position];\n            const hitShip = ships[index];\n            hitShip.hit(position);\n            boardArray[position] = 'hit';\n        }\n    }\n\n    const allShipsSunk = () => {\n        return ships.every(ship => ship.isSunk());\n    }\n\n    return {\n        boardArray,\n        ships,\n        placeShip,\n        removeAllShips,\n        updateShip,\n        receiveAttack,\n        allShipsSunk\n    }\n}\n\n/* harmony default export */ var Factories_GameBoard = (GameBoard);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/BoardDisplay.js\nfunction renderBoard(boardArray, boardDiv) {\n\n    boardArray.forEach( (value, index = 0) => {\n        const cell = document.createElement('div');\n        cell.classList.add('cell');\n        cell.setAttribute('data-key', index);\n        boardDiv.appendChild(cell);\n    })\n}\n\n/* harmony default export */ var BoardDisplay = (renderBoard);\n// EXTERNAL MODULE: ./src/modules/Factories/Player.js\nvar Player = __webpack_require__(0);\nvar Player_default = /*#__PURE__*/__webpack_require__.n(Player);\n\n// CONCATENATED MODULE: ./src/modules/ComputerAttack.js\n\n\nfunction validatePosition(direction, hit, position) {\n    // check if the position is on the board\n    if(position < 0 || position > 99) return undefined;\n\n    // check if on the same row, because rows are wrapped\n    if(direction === 'left' || direction === 'right') {\n        const hitRow = Math.floor(hit / 10);\n        const positionRow = Math.floor(position / 10);\n        if(hitRow !== positionRow) return undefined;\n    }\n\n    // check if position had already been attacked\n    let nextPosition = position\n    let cellValue = selfBoard.boardArray[nextPosition];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        nextPosition = getPositionBasedOnHit(position, direction);\n        cellValue = selfBoard.boardArray[nextPosition];\n    }\n    return nextPosition;\n}\n\nfunction getPositionBasedOnHit(hit, direction) {\n    let position;\n    switch (direction) {\n        case 'up':\n            position = hit - 10;\n            break;\n\n        case 'down':\n            position = hit + 10;\n            break;\n\n        case 'left':\n            position = hit - 1;\n            break;\n\n        case 'right':\n            position = hit + 1;\n    }\n    return validatePosition(direction, hit, position);\n}\n\nfunction getRandomPosition() {\n    let position = Math.floor(Math.random() * 100);\n    let cellValue = selfBoard.boardArray[position];\n    while(cellValue === 'miss' || cellValue === 'hit') {\n        position = Math.floor(Math.random() * 100);\n        cellValue = selfBoard.boardArray[position];\n    }\n    return position;\n}\n\nfunction ComputerAttack() {\n    let hit;\n    let directions = ['up', 'down', 'left', 'right'];\n\n    const updateHits = (position) => {\n        hit = position;\n    }\n\n    const updateMiss = () => {\n        if(!hit) return;\n        directions.shift();\n\n        // If we've checked in all directions, setup variables for next hit\n        if(directions.length === 0) {\n            hit = undefined;\n            directions = ['up', 'down', 'left', 'right'];\n        }\n    }\n\n    const getComputerAttackPosition = () => {\n        if(hit) {\n            console.log('inside ' + hit + directions);\n\n            // get a valid position i.e on board and on same column for vertical ships\n            let position =  getPositionBasedOnHit(hit, directions[0]);\n            while (!position) {\n                directions.shift();\n                if(directions.length === 0) {\n                    hit = undefined;\n                    directions = ['up', 'down', 'left', 'right'];\n                    return getRandomPosition();\n                }\n                position = getPositionBasedOnHit(hit, directions[0]);\n            }\n            return position;\n        }\n        return getRandomPosition();\n    }\n\n    return {getComputerAttackPosition, updateMiss, updateHits};\n}\n\n/* harmony default export */ var modules_ComputerAttack = (ComputerAttack);\n// CONCATENATED MODULE: ./src/modules/GameLoop.js\n\n\n\n\nconst human = Player_default()();\nconst computer = Player_default()();\nconst computerAttack = modules_ComputerAttack();\n\nconst GameLoop_turnInfo = document.querySelector('#turnInfo');\nconst turnText = GameLoop_turnInfo.querySelector('.turn');\n\nlet turn = 'player';\nturnText.textContent = turn;\n\nfunction getTurn() {\n    turn = turn === 'player' ? 'computer' : 'player';\n    return turn;\n}\n\nfunction computerTurn() {\n    // computer's attack on human\n    turnText.textContent = getTurn();\n\n    let position = computerAttack.getComputerAttackPosition();\n    console.log(position);\n    let cell = selfBoardDiv.querySelector(`div[data-key=\"${position}\"]`);\n\n    const computerResult = attack(computer, selfBoard, cell, position);\n    console.log(computerResult);\n\n    // Update hits and misses so computer can make intelligent guesses next time\n    if(computerResult === 'hit') {\n        computerAttack.updateHits(position);\n    } else {\n        computerAttack.updateMiss(position);\n    }\n    selfBoardDiv.classList.add('wait');\n    opponentBoardDiv.classList.remove('wait');\n}\n\nfunction playRound(e) {\n    if(selfBoard.allShipsSunk() || opponentBoard.allShipsSunk()) {\n        const winner = opponentBoard.allShipsSunk() ? 'player' : 'computer';\n        turnText.textContent = `winner is ${winner}`;\n        return;\n    }\n    if(turn === 'computer') return;\n\n    turnText.textContent = getTurn();\n\n    // human's attack on computer\n    let cell = e.target;\n    let position = cell.getAttribute('data-key');\n\n    // Don't play round if user attacks already attacked position\n    if([...cell.classList].includes('hit') || [...cell.classList].includes('miss')) return;\n\n    attack(human, opponentBoard, cell, position);\n    selfBoardDiv.classList.remove('wait');\n    opponentBoardDiv.classList.add('wait');\n    setTimeout(computerTurn,2000);\n}\n\nfunction attack(player, board, cell, position){\n    player.attack(board, position);\n    const result = board.boardArray[position];\n    if (result === 'miss') {\n        cell.classList.add('miss');\n    } else if (result === 'hit'){\n        cell.classList.add('hit');\n    }\n    return result;\n}\n\n/* harmony default export */ var GameLoop = (playRound);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipPlacement.js\nfunction checkValidHorizontalPosition(unaivalablePositions, position, size) {\n    const row = Math.floor(position / 10);\n    const end = (row + 1) * 10;\n\n    // checking if last position will be in the same row\n    if(position + size - 1 >= end) {\n        return false\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position ++;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction checkValidVerticalPosition(unaivalablePositions, position, size) {\n    const col = position % 10;\n    const end = col + 90;\n\n    // checking if last position will be in the same column\n    if(position + (size - 1) * 10 > end) {\n        return false;\n    }\n\n    // check if all positions with this starting position are available\n    for(let i = 0; i < size; i ++) {\n        position += 10;\n        if(unaivalablePositions.includes(position)) return false;\n    }\n\n    return true;\n}\n\nfunction isvalidPosition(unaivalablePositions ,position, size, orientation) {\n    if(unaivalablePositions.includes(position)) return false;\n\n    if(orientation === 'horizontal') {\n        return checkValidHorizontalPosition(unaivalablePositions, position, size);\n    } else {\n        return checkValidVerticalPosition(unaivalablePositions, position, size);\n    }\n}\n\nfunction getValidPosition(unavailablePositions, size, orientation) {\n    let position = Math.floor(Math.random() * 100);\n    while(!isvalidPosition(unavailablePositions, position, size, orientation))\n    {\n        position = Math.floor(Math.random() * 100);\n    }\n    return position;\n}\n\nfunction makeShips() {\n    const unavailablePositions = [];\n    const ships = [];\n    const orientations = [];\n    // let's make 5 ships of sizes 1 to 5\n    for(let size = 1; size <= 5; size ++) {\n        let orientation = size % 2 ? 'vertical' : 'horizontal';\n        orientations.push(orientation);\n\n        let ship = [];\n        let position = getValidPosition(unavailablePositions, size, orientation);\n        for(let i = 0; i < size; i ++) {\n            ship.push(position);\n            unavailablePositions.push(position);\n            if(orientation === 'vertical') {\n                position += 10;\n            } else {\n                position ++;\n            }\n        }\n        ships.push(ship);\n    }\n    console.log(ships, orientations);\n    return {ships, orientations};\n}\n\nconst shipPlacement = {\n    randomPlacement(board) {\n        const {ships, orientations} = makeShips();\n        ships.forEach((ship, index= 0 )=> {\n            board.placeShip(index, ship);\n        });\n        return {ships, orientations};\n    },\n    removeShips(board) {\n        board.removeAllShips();\n    }\n}\n\n/* harmony default export */ var ShipPlacement = (shipPlacement);\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivPlacement.js\n\n\nfunction styleShip(ship, orientation, start, end) {\n    if(orientation === 'vertical') {\n        ship.setAttribute('data-top', start);\n        ship.setAttribute('data-bottom', end);\n    } else {\n        ship.setAttribute('data-left', start);\n        ship.setAttribute('data-right', end);\n    }\n    const topOffset = Math.floor(start/ 10);\n    const leftOffset = start % 10;\n\n    ship.style.top = `${topOffset * 42}px`;\n    ship.style.left = `${leftOffset * 42}px`;\n}\n\nfunction makeShipDiv(orientation, shipNum, length) {\n    const div = document.createElement('div');\n    div.classList.add('ship');\n    div.draggable = true;\n    div.classList.add(orientation);\n    div.setAttribute('data-ship', shipNum);\n    div.setAttribute('data-length', length);\n    if(orientation === 'vertical') {\n        div.style.width = '40px';\n        div.style.height = `${40 * length}px`;\n    } else {\n        div.style.height = '40px';\n        div.style.width = `${40 * length}px`;\n    }\n    return div;\n}\n\nfunction placeShipDivs(container, shipNum, orientation, length, start, end) {\n    const ship = makeShipDiv(orientation, shipNum, length);\n    styleShip(ship, orientation, start, end);\n    container.appendChild(ship);\n}\n\nfunction placeAllShipDivs(ships, orientations) {\n    ships.forEach((ship, index= 0 )=> {\n        const length = ship.length;\n        const start = ship[0];\n        const end = ship[length - 1];\n        placeShipDivs(selfBoardDiv, `${index}`, orientations[index], length, start, end);\n    });\n}\n\nfunction removeAllShipDivs() {\n    const shipDivs = document.querySelectorAll('.ship');\n    shipDivs.forEach(shipDiv => selfBoardDiv.removeChild(shipDiv));\n}\n\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovementHandler.js\n\n\n\nfunction moveShipDiv(ship, cell, orientation, length) {\n    if(orientation === 'vertical') {\n        const newBottom = cell.getAttribute('data-key');\n        const newTop = newBottom - (length - 1) * 10;\n        if(newTop < 0) return;\n\n        styleShip(ship, 'vertical', newTop, newBottom);\n    } else {\n        const newRight = cell.getAttribute('data-key');\n        const row = Math.floor(newRight / 10);\n        const newLeft = newRight - (length - 1);\n        if(newLeft < row * 10) return;\n\n        styleShip(ship, 'horizontal', newLeft, newRight);\n    }\n}\n\nfunction getPositionsFromShipDiv(orientation, length, end) {\n    const positions = [];\n    let position = end;\n\n    const decrement = orientation === 'vertical' ? 10 : 1;\n\n    for(let i = 0; i < length; i ++) {\n        positions.push(position);\n        position -= decrement;\n    }\n    return positions;\n}\n\nfunction areValidPositions(newPositions, oldPositions) {\n    return newPositions.every(newPosition => {\n        // each position must either be empty or one of previous positions\n        return (selfBoard.boardArray[newPosition] === undefined\n                || oldPositions.includes(newPosition)\n        )\n    });\n}\n\n\n// CONCATENATED MODULE: ./src/modules/DomManipulation/ShipDivMovement.js\n\n\n\n// draggable event listeners\nfunction shipDivListeners() {\n    const shipDivs = selfBoardDiv.querySelectorAll('.ship');\n    shipDivs.forEach(ship => ship.addEventListener('dragstart', dragStart));\n    shipDivs.forEach(ship => ship.addEventListener('dragend', dragEnd));\n}\n\n// cell event listeners\nfunction cellListeners() {\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    cells.forEach(cell => cell.addEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.addEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.addEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.addEventListener('drop', dragDrop));\n}\n\nfunction addDragEventListeners() {\n    shipDivListeners();\n    cellListeners();\n}\n\nfunction removeDragEventListeners() {\n    const ships = selfBoardDiv.querySelectorAll('.ship');\n    const cells = selfBoardDiv.querySelectorAll('.cell');\n    // draggable event listeners\n    ships.forEach(ship => ship.removeEventListener('dragstart', dragStart));\n    ships.forEach(ship => ship.removeEventListener('dragend', dragEnd));\n\n    // cell event listeners\n    cells.forEach(cell => cell.removeEventListener('dragover', dragOver));\n    cells.forEach(cell => cell.removeEventListener('dragenter', dragEnter));\n    cells.forEach(cell => cell.removeEventListener('dragleave', dragLeave));\n    cells.forEach(cell => cell.removeEventListener('drop', dragDrop));\n}\n\n// Dragging functions\n\nfunction dragStart(e) {\n    console.log('start');\n    const shipNum = this.getAttribute('data-ship');\n    e.dataTransfer.setData(\"text\", shipNum);\n    setTimeout(() => this.classList.add('hidden'), 0);\n}\n\nfunction dragEnd() {\n    console.log('end');\n    this.classList.remove('hidden');\n}\n\nfunction dragOver(e) {\n    console.log('over');\n    e.preventDefault();\n}\n\nfunction dragEnter() {\n    console.log('enter');\n    this.classList.add('hovered');\n}\n\nfunction dragLeave() {\n    console.log('leave');\n    this.className = 'cell';\n}\n\nfunction dragDrop(e) {\n    console.log('drop');\n    e.preventDefault();\n    const data = e.dataTransfer.getData(\"text\");\n    console.log(data);\n    this.className = 'cell';\n    const ship = selfBoardDiv.querySelector(`.ship[data-ship='${data}']`);\n    const cell = this;\n    console.log(ship, cell);\n    handleDrop(ship, cell);\n}\n\nfunction handleDrop(ship, cell) {\n    // move the div\n    const orientation = [...ship.classList].includes('horizontal') ? 'horizontal' : 'vertical';\n    const length = ship.getAttribute('data-length');\n\n    // get old end and positions\n    const oldEnd = orientation === 'horizontal' ?\n        parseInt(ship.getAttribute('data-right'))\n        : parseInt(ship.getAttribute('data-bottom'));\n    const oldPositions = getPositionsFromShipDiv(orientation, length, oldEnd);\n    console.log(oldEnd, oldPositions);\n\n    // check if moving this div will cause any of the positions to overlap\n    const newEnd = parseInt(cell.getAttribute('data-key'));\n    const newPositions = getPositionsFromShipDiv(orientation, length, newEnd);\n\n    if(!areValidPositions(newPositions, oldPositions)) return;\n    console.log(newEnd, newPositions);\n\n    moveShipDiv(ship, cell, orientation, length);\n\n    const shipIndex = parseInt(ship.getAttribute('data-ship'));\n    console.log(shipIndex, oldPositions, newPositions);\n    selfBoard.updateShip(shipIndex, oldPositions, newPositions);\n}\n\n\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\nconst selfBoard = Factories_GameBoard();\nconst opponentBoard = Factories_GameBoard();\n\nconst selfBoardDiv = document.querySelector('#self');\nconst opponentBoardDiv = document.querySelector('#opponent');\n/******************************************************************************************\n * placement of ships\n *******************************************************************************************/\nlet {ships: src_ships, orientations: src_orientations} = ShipPlacement.randomPlacement(selfBoard);\nplaceAllShipDivs(src_ships, src_orientations);\n\nShipPlacement.randomPlacement(opponentBoard, opponentBoardDiv);\n\nconsole.log(selfBoard);\nconsole.log(opponentBoard);\n\n/******************************************************************************************\n * display boards after ships are placed\n *******************************************************************************************/\n\nBoardDisplay(selfBoard.boardArray, selfBoardDiv);\nBoardDisplay(opponentBoard.boardArray, opponentBoardDiv);\n\naddDragEventListeners();\n\n\n/******************************************************************************************\n * handle events for randomize placement, reset game, start game\n *******************************************************************************************/\nconst gameControls = document.querySelector('#gameControls');\n\nconst randomButton = document.querySelector('#randomButton');\nrandomButton.addEventListener('click', () => {\n    ShipPlacement.removeShips(selfBoard);\n    removeAllShipDivs();\n\n    console.log(selfBoard.boardArray, selfBoard.ships);\n    let res = ShipPlacement.randomPlacement(selfBoard);\n    placeAllShipDivs(res.ships, res.orientations);\n    shipDivListeners();\n    console.log(selfBoard.boardArray, selfBoard.ships);\n\n});\n\nconst startButton = document.querySelector('#startButton');\nstartButton.addEventListener('click', () => {\n    const turnInfo = document.querySelector('#turnInfo');\n    turnInfo.classList.remove('hidden');\n    selfBoardDiv.classList.add('wait');\n    opponentBoardDiv.addEventListener('click', GameLoop);\n    removeDragEventListeners();\n    gameControls.classList.add('hidden');\n});\n\nconst infoButton = document.querySelector('.fa-info-circle');\nconst p = infoButton.nextElementSibling;\nconsole.log(p);\n\ninfoButton.addEventListener('click', () => p.classList.toggle('hidden'))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkLmpzPzkyY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheS5qcz8yYzIyIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0NvbXB1dGVyQXR0YWNrLmpzPzY2NmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvR2FtZUxvb3AuanM/M2Y4YSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcFBsYWNlbWVudC5qcz9mNzQ1Iiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50LmpzPzE2YTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBEaXZNb3ZlbWVudEhhbmRsZXIuanM/Y2UyMSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9Eb21NYW5pcHVsYXRpb24vU2hpcERpdk1vdmVtZW50LmpzP2UyMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGFBQWEsbUJBQU8sQ0FBQyxDQUFROztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7O0FBRWhELFFBQVEsaUJBQWlCO0FBQ3pCOztBQUVBLElBQUksV0FBVzs7QUFFZjtBQUNBO0FBQ0EsSUFBSSxTQUFTO0FBQ2I7O0FBRTJFOzs7QUN6R3JCO0FBQ1c7QUFDdEI7QUFDeUI7QUFLakI7QUFDNEM7O0FBRS9GLGtCQUFrQixtQkFBUztBQUMzQixzQkFBc0IsbUJBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUsseUJBQWMsbUJBQUMsR0FBRyxhQUFhO0FBQ3pDLGdCQUFnQixDQUFDLFNBQUssRUFBRSxnQkFBWTs7QUFFcEMsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1gsWUFBVzs7QUFFWCxxQkFBcUI7QUFDNEM7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakIsSUFBSSxpQkFBaUI7O0FBRXJCO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksZ0JBQWdCO0FBQ3BCOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFTO0FBQ3hELElBQUksd0JBQXdCO0FBQzVCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNoaXAgPSByZXF1aXJlKCcuL1NoaXAnKTtcblxuZnVuY3Rpb24gR2FtZUJvYXJkKCkge1xuICAgIGNvbnN0IGJvYXJkQXJyYXkgPSBbXTtcbiAgICBsZXQgc2hpcHMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgYW4gZW1wdHkgYm9hcmQgb2Ygc2l6ZSAxMCAqIDEwXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDEwMDsgaSArKykge1xuICAgICAgICBib2FyZEFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwbGFjZVNoaXAgPSAoaW5kZXgsIHBvc2l0aW9ucykgPT4ge1xuICAgICAgICBpZihwb3NpdGlvbnMuZXZlcnkocG9zaXRpb24gPT4gYm9hcmRBcnJheVtwb3NpdGlvbl0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaXAgPSBTaGlwKHBvc2l0aW9ucyk7XG4gICAgICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9IGluZGV4KTtcbiAgICAgICAgICAgIHNoaXBzLnB1c2goc2hpcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uZSBvciBtb3JlIHBvc2l0aW9ucyBhcmUgb2NjdXBpZWRcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZUFsbFNoaXBzID0gKCkgPT4ge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTAwOyBpICsrKSB7XG4gICAgICAgICAgICBib2FyZEFycmF5W2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2hpcHMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZVNoaXAgPSAoaW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSBzaGlwIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIG9sZFBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IGJvYXJkQXJyYXlbcG9zaXRpb25dID0gdW5kZWZpbmVkKTtcblxuICAgICAgICBzaGlwcy5mb3JFYWNoKHNoaXAgPT4gY29uc29sZS5sb2coc2hpcC5nZXRQb3NpdGlvbnMoKSkpO1xuICAgICAgICAvLyByZXBsYWNlIG9sZCBzaGlwIHdpdGggbmV3IHNoaXBcbiAgICAgICAgc2hpcHNbaW5kZXhdID0gU2hpcChuZXdQb3NpdGlvbnMpO1xuXG4gICAgICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBjb25zb2xlLmxvZyhzaGlwLmdldFBvc2l0aW9ucygpKSk7XG4gICAgICAgIC8vIHBsYWNlIHRoaXMgc2hpcCBvbiB0aGUgYm9hcmRBcnJheVxuICAgICAgICBuZXdQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBib2FyZEFycmF5W3Bvc2l0aW9uXSA9IGluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNlaXZlQXR0YWNrID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmKGJvYXJkQXJyYXlbcG9zaXRpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJvYXJkQXJyYXlbcG9zaXRpb25dID0gJ21pc3MnO1xuICAgICAgICB9IGVsc2UgaWYgKGJvYXJkQXJyYXlbcG9zaXRpb25dICE9PSAnbWlzcycgJiYgYm9hcmRBcnJheVtwb3NpdGlvbl0gIT09ICdoaXQnKXtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBjb25zdCBoaXRTaGlwID0gc2hpcHNbaW5kZXhdO1xuICAgICAgICAgICAgaGl0U2hpcC5oaXQocG9zaXRpb24pO1xuICAgICAgICAgICAgYm9hcmRBcnJheVtwb3NpdGlvbl0gPSAnaGl0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFsbFNoaXBzU3VuayA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNoaXBzLmV2ZXJ5KHNoaXAgPT4gc2hpcC5pc1N1bmsoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9hcmRBcnJheSxcbiAgICAgICAgc2hpcHMsXG4gICAgICAgIHBsYWNlU2hpcCxcbiAgICAgICAgcmVtb3ZlQWxsU2hpcHMsXG4gICAgICAgIHVwZGF0ZVNoaXAsXG4gICAgICAgIHJlY2VpdmVBdHRhY2ssXG4gICAgICAgIGFsbFNoaXBzU3Vua1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2FtZUJvYXJkO1xuIiwiZnVuY3Rpb24gcmVuZGVyQm9hcmQoYm9hcmRBcnJheSwgYm9hcmREaXYpIHtcblxuICAgIGJvYXJkQXJyYXkuZm9yRWFjaCggKHZhbHVlLCBpbmRleCA9IDApID0+IHtcbiAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ2NlbGwnKTtcbiAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2RhdGEta2V5JywgaW5kZXgpO1xuICAgICAgICBib2FyZERpdi5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJCb2FyZDsiLCJpbXBvcnQge3NlbGZCb2FyZH0gZnJvbSAnLi4vaW5kZXgnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aW9uKGRpcmVjdGlvbiwgaGl0LCBwb3NpdGlvbikge1xuICAgIC8vIGNoZWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvbiB0aGUgYm9hcmRcbiAgICBpZihwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiA5OSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIC8vIGNoZWNrIGlmIG9uIHRoZSBzYW1lIHJvdywgYmVjYXVzZSByb3dzIGFyZSB3cmFwcGVkXG4gICAgaWYoZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IGhpdFJvdyA9IE1hdGguZmxvb3IoaGl0IC8gMTApO1xuICAgICAgICBjb25zdCBwb3NpdGlvblJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyAxMCk7XG4gICAgICAgIGlmKGhpdFJvdyAhPT0gcG9zaXRpb25Sb3cpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgcG9zaXRpb24gaGFkIGFscmVhZHkgYmVlbiBhdHRhY2tlZFxuICAgIGxldCBuZXh0UG9zaXRpb24gPSBwb3NpdGlvblxuICAgIGxldCBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXh0UG9zaXRpb25dO1xuICAgIHdoaWxlKGNlbGxWYWx1ZSA9PT0gJ21pc3MnIHx8IGNlbGxWYWx1ZSA9PT0gJ2hpdCcpIHtcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gZ2V0UG9zaXRpb25CYXNlZE9uSGl0KHBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXh0UG9zaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkJhc2VkT25IaXQoaGl0LCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndXAnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgLSAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgKyAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcG9zaXRpb24gPSBoaXQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIGhpdCwgcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21Qb3NpdGlvbigpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIGxldCBjZWxsVmFsdWUgPSBzZWxmQm9hcmQuYm9hcmRBcnJheVtwb3NpdGlvbl07XG4gICAgd2hpbGUoY2VsbFZhbHVlID09PSAnbWlzcycgfHwgY2VsbFZhbHVlID09PSAnaGl0Jykge1xuICAgICAgICBwb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgIGNlbGxWYWx1ZSA9IHNlbGZCb2FyZC5ib2FyZEFycmF5W3Bvc2l0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBDb21wdXRlckF0dGFjaygpIHtcbiAgICBsZXQgaGl0O1xuICAgIGxldCBkaXJlY3Rpb25zID0gWyd1cCcsICdkb3duJywgJ2xlZnQnLCAncmlnaHQnXTtcblxuICAgIGNvbnN0IHVwZGF0ZUhpdHMgPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgaGl0ID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlTWlzcyA9ICgpID0+IHtcbiAgICAgICAgaWYoIWhpdCkgcmV0dXJuO1xuICAgICAgICBkaXJlY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgY2hlY2tlZCBpbiBhbGwgZGlyZWN0aW9ucywgc2V0dXAgdmFyaWFibGVzIGZvciBuZXh0IGhpdFxuICAgICAgICBpZihkaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGlyZWN0aW9ucyA9IFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnZXRDb21wdXRlckF0dGFja1Bvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZihoaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbnNpZGUgJyArIGhpdCArIGRpcmVjdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBnZXQgYSB2YWxpZCBwb3NpdGlvbiBpLmUgb24gYm9hcmQgYW5kIG9uIHNhbWUgY29sdW1uIGZvciB2ZXJ0aWNhbCBzaGlwc1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gIGdldFBvc2l0aW9uQmFzZWRPbkhpdChoaXQsIGRpcmVjdGlvbnNbMF0pO1xuICAgICAgICAgICAgd2hpbGUgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBoaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZG9tUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkJhc2VkT25IaXQoaGl0LCBkaXJlY3Rpb25zWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0UmFuZG9tUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2dldENvbXB1dGVyQXR0YWNrUG9zaXRpb24sIHVwZGF0ZU1pc3MsIHVwZGF0ZUhpdHN9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wdXRlckF0dGFjazsiLCJpbXBvcnQgUGxheWVyIGZyb20gJy4vRmFjdG9yaWVzL1BsYXllcic7XG5pbXBvcnQge3NlbGZCb2FyZCwgb3Bwb25lbnRCb2FyZCwgc2VsZkJvYXJkRGl2LCBvcHBvbmVudEJvYXJkRGl2fSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgQ29tcHV0ZXJBdHRhY2sgZnJvbSAnLi9Db21wdXRlckF0dGFjayc7XG5cbmNvbnN0IGh1bWFuID0gUGxheWVyKCk7XG5jb25zdCBjb21wdXRlciA9IFBsYXllcigpO1xuY29uc3QgY29tcHV0ZXJBdHRhY2sgPSBDb21wdXRlckF0dGFjaygpO1xuXG5jb25zdCB0dXJuSW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0dXJuSW5mbycpO1xuY29uc3QgdHVyblRleHQgPSB0dXJuSW5mby5xdWVyeVNlbGVjdG9yKCcudHVybicpO1xuXG5sZXQgdHVybiA9ICdwbGF5ZXInO1xudHVyblRleHQudGV4dENvbnRlbnQgPSB0dXJuO1xuXG5mdW5jdGlvbiBnZXRUdXJuKCkge1xuICAgIHR1cm4gPSB0dXJuID09PSAncGxheWVyJyA/ICdjb21wdXRlcicgOiAncGxheWVyJztcbiAgICByZXR1cm4gdHVybjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZXJUdXJuKCkge1xuICAgIC8vIGNvbXB1dGVyJ3MgYXR0YWNrIG9uIGh1bWFuXG4gICAgdHVyblRleHQudGV4dENvbnRlbnQgPSBnZXRUdXJuKCk7XG5cbiAgICBsZXQgcG9zaXRpb24gPSBjb21wdXRlckF0dGFjay5nZXRDb21wdXRlckF0dGFja1Bvc2l0aW9uKCk7XG4gICAgY29uc29sZS5sb2cocG9zaXRpb24pO1xuICAgIGxldCBjZWxsID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3IoYGRpdltkYXRhLWtleT1cIiR7cG9zaXRpb259XCJdYCk7XG5cbiAgICBjb25zdCBjb21wdXRlclJlc3VsdCA9IGF0dGFjayhjb21wdXRlciwgc2VsZkJvYXJkLCBjZWxsLCBwb3NpdGlvbik7XG4gICAgY29uc29sZS5sb2coY29tcHV0ZXJSZXN1bHQpO1xuXG4gICAgLy8gVXBkYXRlIGhpdHMgYW5kIG1pc3NlcyBzbyBjb21wdXRlciBjYW4gbWFrZSBpbnRlbGxpZ2VudCBndWVzc2VzIG5leHQgdGltZVxuICAgIGlmKGNvbXB1dGVyUmVzdWx0ID09PSAnaGl0Jykge1xuICAgICAgICBjb21wdXRlckF0dGFjay51cGRhdGVIaXRzKHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wdXRlckF0dGFjay51cGRhdGVNaXNzKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgc2VsZkJvYXJkRGl2LmNsYXNzTGlzdC5hZGQoJ3dhaXQnKTtcbiAgICBvcHBvbmVudEJvYXJkRGl2LmNsYXNzTGlzdC5yZW1vdmUoJ3dhaXQnKTtcbn1cblxuZnVuY3Rpb24gcGxheVJvdW5kKGUpIHtcbiAgICBpZihzZWxmQm9hcmQuYWxsU2hpcHNTdW5rKCkgfHwgb3Bwb25lbnRCb2FyZC5hbGxTaGlwc1N1bmsoKSkge1xuICAgICAgICBjb25zdCB3aW5uZXIgPSBvcHBvbmVudEJvYXJkLmFsbFNoaXBzU3VuaygpID8gJ3BsYXllcicgOiAnY29tcHV0ZXInO1xuICAgICAgICB0dXJuVGV4dC50ZXh0Q29udGVudCA9IGB3aW5uZXIgaXMgJHt3aW5uZXJ9YDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0dXJuID09PSAnY29tcHV0ZXInKSByZXR1cm47XG5cbiAgICB0dXJuVGV4dC50ZXh0Q29udGVudCA9IGdldFR1cm4oKTtcblxuICAgIC8vIGh1bWFuJ3MgYXR0YWNrIG9uIGNvbXB1dGVyXG4gICAgbGV0IGNlbGwgPSBlLnRhcmdldDtcbiAgICBsZXQgcG9zaXRpb24gPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKTtcblxuICAgIC8vIERvbid0IHBsYXkgcm91bmQgaWYgdXNlciBhdHRhY2tzIGFscmVhZHkgYXR0YWNrZWQgcG9zaXRpb25cbiAgICBpZihbLi4uY2VsbC5jbGFzc0xpc3RdLmluY2x1ZGVzKCdoaXQnKSB8fCBbLi4uY2VsbC5jbGFzc0xpc3RdLmluY2x1ZGVzKCdtaXNzJykpIHJldHVybjtcblxuICAgIGF0dGFjayhodW1hbiwgb3Bwb25lbnRCb2FyZCwgY2VsbCwgcG9zaXRpb24pO1xuICAgIHNlbGZCb2FyZERpdi5jbGFzc0xpc3QucmVtb3ZlKCd3YWl0Jyk7XG4gICAgb3Bwb25lbnRCb2FyZERpdi5jbGFzc0xpc3QuYWRkKCd3YWl0Jyk7XG4gICAgc2V0VGltZW91dChjb21wdXRlclR1cm4sMjAwMCk7XG59XG5cbmZ1bmN0aW9uIGF0dGFjayhwbGF5ZXIsIGJvYXJkLCBjZWxsLCBwb3NpdGlvbil7XG4gICAgcGxheWVyLmF0dGFjayhib2FyZCwgcG9zaXRpb24pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGJvYXJkLmJvYXJkQXJyYXlbcG9zaXRpb25dO1xuICAgIGlmIChyZXN1bHQgPT09ICdtaXNzJykge1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ21pc3MnKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gJ2hpdCcpe1xuICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ2hpdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBwbGF5Um91bmQ7XG4iLCJmdW5jdGlvbiBjaGVja1ZhbGlkSG9yaXpvbnRhbFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSkge1xuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyAxMCk7XG4gICAgY29uc3QgZW5kID0gKHJvdyArIDEpICogMTA7XG5cbiAgICAvLyBjaGVja2luZyBpZiBsYXN0IHBvc2l0aW9uIHdpbGwgYmUgaW4gdGhlIHNhbWUgcm93XG4gICAgaWYocG9zaXRpb24gKyBzaXplIC0gMSA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIHBvc2l0aW9ucyB3aXRoIHRoaXMgc3RhcnRpbmcgcG9zaXRpb24gYXJlIGF2YWlsYWJsZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9uICsrO1xuICAgICAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZFZlcnRpY2FsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKSB7XG4gICAgY29uc3QgY29sID0gcG9zaXRpb24gJSAxMDtcbiAgICBjb25zdCBlbmQgPSBjb2wgKyA5MDtcblxuICAgIC8vIGNoZWNraW5nIGlmIGxhc3QgcG9zaXRpb24gd2lsbCBiZSBpbiB0aGUgc2FtZSBjb2x1bW5cbiAgICBpZihwb3NpdGlvbiArIChzaXplIC0gMSkgKiAxMCA+IGVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIHBvc2l0aW9ucyB3aXRoIHRoaXMgc3RhcnRpbmcgcG9zaXRpb24gYXJlIGF2YWlsYWJsZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IDEwO1xuICAgICAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXN2YWxpZFBvc2l0aW9uKHVuYWl2YWxhYmxlUG9zaXRpb25zICxwb3NpdGlvbiwgc2l6ZSwgb3JpZW50YXRpb24pIHtcbiAgICBpZih1bmFpdmFsYWJsZVBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHJldHVybiBmYWxzZTtcblxuICAgIGlmKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrVmFsaWRIb3Jpem9udGFsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tWYWxpZFZlcnRpY2FsUG9zaXRpb24odW5haXZhbGFibGVQb3NpdGlvbnMsIHBvc2l0aW9uLCBzaXplKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFZhbGlkUG9zaXRpb24odW5hdmFpbGFibGVQb3NpdGlvbnMsIHNpemUsIG9yaWVudGF0aW9uKSB7XG4gICAgbGV0IHBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB3aGlsZSghaXN2YWxpZFBvc2l0aW9uKHVuYXZhaWxhYmxlUG9zaXRpb25zLCBwb3NpdGlvbiwgc2l6ZSwgb3JpZW50YXRpb24pKVxuICAgIHtcbiAgICAgICAgcG9zaXRpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIG1ha2VTaGlwcygpIHtcbiAgICBjb25zdCB1bmF2YWlsYWJsZVBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHNoaXBzID0gW107XG4gICAgY29uc3Qgb3JpZW50YXRpb25zID0gW107XG4gICAgLy8gbGV0J3MgbWFrZSA1IHNoaXBzIG9mIHNpemVzIDEgdG8gNVxuICAgIGZvcihsZXQgc2l6ZSA9IDE7IHNpemUgPD0gNTsgc2l6ZSArKykge1xuICAgICAgICBsZXQgb3JpZW50YXRpb24gPSBzaXplICUgMiA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIG9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcblxuICAgICAgICBsZXQgc2hpcCA9IFtdO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBnZXRWYWxpZFBvc2l0aW9uKHVuYXZhaWxhYmxlUG9zaXRpb25zLCBzaXplLCBvcmllbnRhdGlvbik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrKSB7XG4gICAgICAgICAgICBzaGlwLnB1c2gocG9zaXRpb24pO1xuICAgICAgICAgICAgdW5hdmFpbGFibGVQb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICAgICAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDEwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaGlwcy5wdXNoKHNoaXApO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhzaGlwcywgb3JpZW50YXRpb25zKTtcbiAgICByZXR1cm4ge3NoaXBzLCBvcmllbnRhdGlvbnN9O1xufVxuXG5jb25zdCBzaGlwUGxhY2VtZW50ID0ge1xuICAgIHJhbmRvbVBsYWNlbWVudChib2FyZCkge1xuICAgICAgICBjb25zdCB7c2hpcHMsIG9yaWVudGF0aW9uc30gPSBtYWtlU2hpcHMoKTtcbiAgICAgICAgc2hpcHMuZm9yRWFjaCgoc2hpcCwgaW5kZXg9IDAgKT0+IHtcbiAgICAgICAgICAgIGJvYXJkLnBsYWNlU2hpcChpbmRleCwgc2hpcCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge3NoaXBzLCBvcmllbnRhdGlvbnN9O1xuICAgIH0sXG4gICAgcmVtb3ZlU2hpcHMoYm9hcmQpIHtcbiAgICAgICAgYm9hcmQucmVtb3ZlQWxsU2hpcHMoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoaXBQbGFjZW1lbnQ7XG4iLCJpbXBvcnQge3NlbGZCb2FyZERpdn0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIHN0eWxlU2hpcChzaGlwLCBvcmllbnRhdGlvbiwgc3RhcnQsIGVuZCkge1xuICAgIGlmKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHNoaXAuc2V0QXR0cmlidXRlKCdkYXRhLXRvcCcsIHN0YXJ0KTtcbiAgICAgICAgc2hpcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm90dG9tJywgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1sZWZ0Jywgc3RhcnQpO1xuICAgICAgICBzaGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1yaWdodCcsIGVuZCk7XG4gICAgfVxuICAgIGNvbnN0IHRvcE9mZnNldCA9IE1hdGguZmxvb3Ioc3RhcnQvIDEwKTtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gc3RhcnQgJSAxMDtcblxuICAgIHNoaXAuc3R5bGUudG9wID0gYCR7dG9wT2Zmc2V0ICogNDJ9cHhgO1xuICAgIHNoaXAuc3R5bGUubGVmdCA9IGAke2xlZnRPZmZzZXQgKiA0Mn1weGA7XG59XG5cbmZ1bmN0aW9uIG1ha2VTaGlwRGl2KG9yaWVudGF0aW9uLCBzaGlwTnVtLCBsZW5ndGgpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCgnc2hpcCcpO1xuICAgIGRpdi5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKG9yaWVudGF0aW9uKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLXNoaXAnLCBzaGlwTnVtKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLWxlbmd0aCcsIGxlbmd0aCk7XG4gICAgaWYob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzQwcHgnO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7NDAgKiBsZW5ndGh9cHhgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnNDBweCc7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAkezQwICogbGVuZ3RofXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gcGxhY2VTaGlwRGl2cyhjb250YWluZXIsIHNoaXBOdW0sIG9yaWVudGF0aW9uLCBsZW5ndGgsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBzaGlwID0gbWFrZVNoaXBEaXYob3JpZW50YXRpb24sIHNoaXBOdW0sIGxlbmd0aCk7XG4gICAgc3R5bGVTaGlwKHNoaXAsIG9yaWVudGF0aW9uLCBzdGFydCwgZW5kKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc2hpcCk7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQWxsU2hpcERpdnMoc2hpcHMsIG9yaWVudGF0aW9ucykge1xuICAgIHNoaXBzLmZvckVhY2goKHNoaXAsIGluZGV4PSAwICk9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNoaXAubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGFydCA9IHNoaXBbMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHNoaXBbbGVuZ3RoIC0gMV07XG4gICAgICAgIHBsYWNlU2hpcERpdnMoc2VsZkJvYXJkRGl2LCBgJHtpbmRleH1gLCBvcmllbnRhdGlvbnNbaW5kZXhdLCBsZW5ndGgsIHN0YXJ0LCBlbmQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxTaGlwRGl2cygpIHtcbiAgICBjb25zdCBzaGlwRGl2cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaGlwJyk7XG4gICAgc2hpcERpdnMuZm9yRWFjaChzaGlwRGl2ID0+IHNlbGZCb2FyZERpdi5yZW1vdmVDaGlsZChzaGlwRGl2KSk7XG59XG5cbmV4cG9ydCB7c3R5bGVTaGlwLCBwbGFjZUFsbFNoaXBEaXZzLCByZW1vdmVBbGxTaGlwRGl2c307XG4iLCJpbXBvcnQge3N0eWxlU2hpcH0gZnJvbSAnLi9TaGlwRGl2UGxhY2VtZW50JztcbmltcG9ydCB7c2VsZkJvYXJkfSBmcm9tICcuLi8uLi9pbmRleCc7XG5cbmZ1bmN0aW9uIG1vdmVTaGlwRGl2KHNoaXAsIGNlbGwsIG9yaWVudGF0aW9uLCBsZW5ndGgpIHtcbiAgICBpZihvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBjb25zdCBuZXdCb3R0b20gPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKTtcbiAgICAgICAgY29uc3QgbmV3VG9wID0gbmV3Qm90dG9tIC0gKGxlbmd0aCAtIDEpICogMTA7XG4gICAgICAgIGlmKG5ld1RvcCA8IDApIHJldHVybjtcblxuICAgICAgICBzdHlsZVNoaXAoc2hpcCwgJ3ZlcnRpY2FsJywgbmV3VG9wLCBuZXdCb3R0b20pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Jyk7XG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IobmV3UmlnaHQgLyAxMCk7XG4gICAgICAgIGNvbnN0IG5ld0xlZnQgPSBuZXdSaWdodCAtIChsZW5ndGggLSAxKTtcbiAgICAgICAgaWYobmV3TGVmdCA8IHJvdyAqIDEwKSByZXR1cm47XG5cbiAgICAgICAgc3R5bGVTaGlwKHNoaXAsICdob3Jpem9udGFsJywgbmV3TGVmdCwgbmV3UmlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYob3JpZW50YXRpb24sIGxlbmd0aCwgZW5kKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgbGV0IHBvc2l0aW9uID0gZW5kO1xuXG4gICAgY29uc3QgZGVjcmVtZW50ID0gb3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyAxMCA6IDE7XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gLT0gZGVjcmVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiBhcmVWYWxpZFBvc2l0aW9ucyhuZXdQb3NpdGlvbnMsIG9sZFBvc2l0aW9ucykge1xuICAgIHJldHVybiBuZXdQb3NpdGlvbnMuZXZlcnkobmV3UG9zaXRpb24gPT4ge1xuICAgICAgICAvLyBlYWNoIHBvc2l0aW9uIG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIG9uZSBvZiBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgcmV0dXJuIChzZWxmQm9hcmQuYm9hcmRBcnJheVtuZXdQb3NpdGlvbl0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHx8IG9sZFBvc2l0aW9ucy5pbmNsdWRlcyhuZXdQb3NpdGlvbilcbiAgICAgICAgKVxuICAgIH0pO1xufVxuXG5leHBvcnQgIHttb3ZlU2hpcERpdiwgZ2V0UG9zaXRpb25zRnJvbVNoaXBEaXYsIGFyZVZhbGlkUG9zaXRpb25zfTsiLCJpbXBvcnQge3NlbGZCb2FyZCwgc2VsZkJvYXJkRGl2fSBmcm9tICcuLi8uLi9pbmRleCc7XG5pbXBvcnQge2FyZVZhbGlkUG9zaXRpb25zLCBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdiwgbW92ZVNoaXBEaXZ9IGZyb20gJy4vU2hpcERpdk1vdmVtZW50SGFuZGxlcic7XG5cbi8vIGRyYWdnYWJsZSBldmVudCBsaXN0ZW5lcnNcbmZ1bmN0aW9uIHNoaXBEaXZMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc2hpcERpdnMgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvckFsbCgnLnNoaXAnKTtcbiAgICBzaGlwRGl2cy5mb3JFYWNoKHNoaXAgPT4gc2hpcC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpKTtcbiAgICBzaGlwRGl2cy5mb3JFYWNoKHNoaXAgPT4gc2hpcC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgZHJhZ0VuZCkpO1xufVxuXG4vLyBjZWxsIGV2ZW50IGxpc3RlbmVyc1xuZnVuY3Rpb24gY2VsbExpc3RlbmVycygpIHtcbiAgICBjb25zdCBjZWxscyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY2VsbCcpO1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ092ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBkcmFnRW50ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgZHJhZ0Ryb3ApKTtcbn1cblxuZnVuY3Rpb24gYWRkRHJhZ0V2ZW50TGlzdGVuZXJzKCkge1xuICAgIHNoaXBEaXZMaXN0ZW5lcnMoKTtcbiAgICBjZWxsTGlzdGVuZXJzKCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURyYWdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaGlwcyA9IHNlbGZCb2FyZERpdi5xdWVyeVNlbGVjdG9yQWxsKCcuc2hpcCcpO1xuICAgIGNvbnN0IGNlbGxzID0gc2VsZkJvYXJkRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jZWxsJyk7XG4gICAgLy8gZHJhZ2dhYmxlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGRyYWdTdGFydCkpO1xuICAgIHNoaXBzLmZvckVhY2goc2hpcCA9PiBzaGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBkcmFnRW5kKSk7XG5cbiAgICAvLyBjZWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZHJhZ092ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBkcmFnRW50ZXIpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBkcmFnTGVhdmUpKTtcbiAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gY2VsbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgZHJhZ0Ryb3ApKTtcbn1cblxuLy8gRHJhZ2dpbmcgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG4gICAgY29uc29sZS5sb2coJ3N0YXJ0Jyk7XG4gICAgY29uc3Qgc2hpcE51bSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXNoaXAnKTtcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBzaGlwTnVtKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyksIDApO1xufVxuXG5mdW5jdGlvbiBkcmFnRW5kKCkge1xuICAgIGNvbnNvbGUubG9nKCdlbmQnKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xufVxuXG5mdW5jdGlvbiBkcmFnT3ZlcihlKSB7XG4gICAgY29uc29sZS5sb2coJ292ZXInKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIGRyYWdFbnRlcigpIHtcbiAgICBjb25zb2xlLmxvZygnZW50ZXInKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2hvdmVyZWQnKTtcbn1cblxuZnVuY3Rpb24gZHJhZ0xlYXZlKCkge1xuICAgIGNvbnNvbGUubG9nKCdsZWF2ZScpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gJ2NlbGwnO1xufVxuXG5mdW5jdGlvbiBkcmFnRHJvcChlKSB7XG4gICAgY29uc29sZS5sb2coJ2Ryb3AnKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZGF0YSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0XCIpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gJ2NlbGwnO1xuICAgIGNvbnN0IHNoaXAgPSBzZWxmQm9hcmREaXYucXVlcnlTZWxlY3RvcihgLnNoaXBbZGF0YS1zaGlwPScke2RhdGF9J11gKTtcbiAgICBjb25zdCBjZWxsID0gdGhpcztcbiAgICBjb25zb2xlLmxvZyhzaGlwLCBjZWxsKTtcbiAgICBoYW5kbGVEcm9wKHNoaXAsIGNlbGwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEcm9wKHNoaXAsIGNlbGwpIHtcbiAgICAvLyBtb3ZlIHRoZSBkaXZcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IFsuLi5zaGlwLmNsYXNzTGlzdF0uaW5jbHVkZXMoJ2hvcml6b250YWwnKSA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgY29uc3QgbGVuZ3RoID0gc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGVuZ3RoJyk7XG5cbiAgICAvLyBnZXQgb2xkIGVuZCBhbmQgcG9zaXRpb25zXG4gICAgY29uc3Qgb2xkRW5kID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgIHBhcnNlSW50KHNoaXAuZ2V0QXR0cmlidXRlKCdkYXRhLXJpZ2h0JykpXG4gICAgICAgIDogcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYm90dG9tJykpO1xuICAgIGNvbnN0IG9sZFBvc2l0aW9ucyA9IGdldFBvc2l0aW9uc0Zyb21TaGlwRGl2KG9yaWVudGF0aW9uLCBsZW5ndGgsIG9sZEVuZCk7XG4gICAgY29uc29sZS5sb2cob2xkRW5kLCBvbGRQb3NpdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbW92aW5nIHRoaXMgZGl2IHdpbGwgY2F1c2UgYW55IG9mIHRoZSBwb3NpdGlvbnMgdG8gb3ZlcmxhcFxuICAgIGNvbnN0IG5ld0VuZCA9IHBhcnNlSW50KGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbnMgPSBnZXRQb3NpdGlvbnNGcm9tU2hpcERpdihvcmllbnRhdGlvbiwgbGVuZ3RoLCBuZXdFbmQpO1xuXG4gICAgaWYoIWFyZVZhbGlkUG9zaXRpb25zKG5ld1Bvc2l0aW9ucywgb2xkUG9zaXRpb25zKSkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKG5ld0VuZCwgbmV3UG9zaXRpb25zKTtcblxuICAgIG1vdmVTaGlwRGl2KHNoaXAsIGNlbGwsIG9yaWVudGF0aW9uLCBsZW5ndGgpO1xuXG4gICAgY29uc3Qgc2hpcEluZGV4ID0gcGFyc2VJbnQoc2hpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2hpcCcpKTtcbiAgICBjb25zb2xlLmxvZyhzaGlwSW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKTtcbiAgICBzZWxmQm9hcmQudXBkYXRlU2hpcChzaGlwSW5kZXgsIG9sZFBvc2l0aW9ucywgbmV3UG9zaXRpb25zKTtcbn1cblxuZXhwb3J0IHthZGREcmFnRXZlbnRMaXN0ZW5lcnMsIHJlbW92ZURyYWdFdmVudExpc3RlbmVycywgc2hpcERpdkxpc3RlbmVyc307XG4iLCJpbXBvcnQgR2FtZUJvYXJkIGZyb20gJy4vbW9kdWxlcy9GYWN0b3JpZXMvR2FtZUJvYXJkJztcbmltcG9ydCByZW5kZXJCb2FyZCBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL0JvYXJkRGlzcGxheSc7XG5pbXBvcnQgcGxheVJvdW5kIGZyb20gJy4vbW9kdWxlcy9HYW1lTG9vcCc7XG5pbXBvcnQgc2hpcFBsYWNlbWVudCBmcm9tICcuL21vZHVsZXMvRG9tTWFuaXB1bGF0aW9uL1NoaXBQbGFjZW1lbnQnO1xuaW1wb3J0IHtcbiAgICBhZGREcmFnRXZlbnRMaXN0ZW5lcnMsXG4gICAgcmVtb3ZlRHJhZ0V2ZW50TGlzdGVuZXJzLFxuICAgIHNoaXBEaXZMaXN0ZW5lcnNcbn0gZnJvbSAnLi9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2TW92ZW1lbnQnO1xuaW1wb3J0IHtwbGFjZUFsbFNoaXBEaXZzLCByZW1vdmVBbGxTaGlwRGl2c30gZnJvbSAnLi9tb2R1bGVzL0RvbU1hbmlwdWxhdGlvbi9TaGlwRGl2UGxhY2VtZW50JztcblxuY29uc3Qgc2VsZkJvYXJkID0gR2FtZUJvYXJkKCk7XG5jb25zdCBvcHBvbmVudEJvYXJkID0gR2FtZUJvYXJkKCk7XG5cbmNvbnN0IHNlbGZCb2FyZERpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWxmJyk7XG5jb25zdCBvcHBvbmVudEJvYXJkRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI29wcG9uZW50Jyk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBwbGFjZW1lbnQgb2Ygc2hpcHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xubGV0IHtzaGlwcywgb3JpZW50YXRpb25zfSA9IHNoaXBQbGFjZW1lbnQucmFuZG9tUGxhY2VtZW50KHNlbGZCb2FyZCk7XG5wbGFjZUFsbFNoaXBEaXZzKHNoaXBzLCBvcmllbnRhdGlvbnMpO1xuXG5zaGlwUGxhY2VtZW50LnJhbmRvbVBsYWNlbWVudChvcHBvbmVudEJvYXJkLCBvcHBvbmVudEJvYXJkRGl2KTtcblxuY29uc29sZS5sb2coc2VsZkJvYXJkKTtcbmNvbnNvbGUubG9nKG9wcG9uZW50Qm9hcmQpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBkaXNwbGF5IGJvYXJkcyBhZnRlciBzaGlwcyBhcmUgcGxhY2VkXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxucmVuZGVyQm9hcmQoc2VsZkJvYXJkLmJvYXJkQXJyYXksIHNlbGZCb2FyZERpdik7XG5yZW5kZXJCb2FyZChvcHBvbmVudEJvYXJkLmJvYXJkQXJyYXksIG9wcG9uZW50Qm9hcmREaXYpO1xuXG5hZGREcmFnRXZlbnRMaXN0ZW5lcnMoKTtcbmV4cG9ydCB7b3Bwb25lbnRCb2FyZCwgc2VsZkJvYXJkLCBvcHBvbmVudEJvYXJkRGl2LCBzZWxmQm9hcmREaXZ9XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIGhhbmRsZSBldmVudHMgZm9yIHJhbmRvbWl6ZSBwbGFjZW1lbnQsIHJlc2V0IGdhbWUsIHN0YXJ0IGdhbWVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuY29uc3QgZ2FtZUNvbnRyb2xzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dhbWVDb250cm9scycpO1xuXG5jb25zdCByYW5kb21CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcmFuZG9tQnV0dG9uJyk7XG5yYW5kb21CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2hpcFBsYWNlbWVudC5yZW1vdmVTaGlwcyhzZWxmQm9hcmQpO1xuICAgIHJlbW92ZUFsbFNoaXBEaXZzKCk7XG5cbiAgICBjb25zb2xlLmxvZyhzZWxmQm9hcmQuYm9hcmRBcnJheSwgc2VsZkJvYXJkLnNoaXBzKTtcbiAgICBsZXQgcmVzID0gc2hpcFBsYWNlbWVudC5yYW5kb21QbGFjZW1lbnQoc2VsZkJvYXJkKTtcbiAgICBwbGFjZUFsbFNoaXBEaXZzKHJlcy5zaGlwcywgcmVzLm9yaWVudGF0aW9ucyk7XG4gICAgc2hpcERpdkxpc3RlbmVycygpO1xuICAgIGNvbnNvbGUubG9nKHNlbGZCb2FyZC5ib2FyZEFycmF5LCBzZWxmQm9hcmQuc2hpcHMpO1xuXG59KTtcblxuY29uc3Qgc3RhcnRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnRCdXR0b24nKTtcbnN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IHR1cm5JbmZvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3R1cm5JbmZvJyk7XG4gICAgdHVybkluZm8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgc2VsZkJvYXJkRGl2LmNsYXNzTGlzdC5hZGQoJ3dhaXQnKTtcbiAgICBvcHBvbmVudEJvYXJkRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcGxheVJvdW5kKTtcbiAgICByZW1vdmVEcmFnRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBnYW1lQ29udHJvbHMuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG59KTtcblxuY29uc3QgaW5mb0J1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYS1pbmZvLWNpcmNsZScpO1xuY29uc3QgcCA9IGluZm9CdXR0b24ubmV4dEVsZW1lbnRTaWJsaW5nO1xuY29uc29sZS5sb2cocCk7XG5cbmluZm9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBwLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")}]);